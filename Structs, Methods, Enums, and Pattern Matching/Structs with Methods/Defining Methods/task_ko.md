### 메서드 정의하기

`Rectangle` 인스턴스를 매개변수로 갖는 `area` 함수를 변경하여, 아래와 같이 `Rectangle` 구조체에 정의된 `area` 메서드를 만들어 보겠습니다.

<span class="filename">파일 이름: src/main.rs</span>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

#### `Rectangle` 구조체에서 `area` 메서드 정의하기

`Rectangle`의 컨텍스트 내에서 함수를 정의하려면 `impl`(구현) 블록을 시작합니다. 그런 다음 `impl` 중괄호 안에 `area` 함수를 이동시키고, 시그니처에서 첫 번째 (그리고 이 경우 유일한) 매개변수를 `self`로 변경하며 함수 본문에서도 이를 사용합니다. `main`에서 `area` 함수를 호출하고 `rect1`을 인수로 전달했던 부분을 대신 *메서드 문법*을 사용해 `Rectangle` 인스턴스에서 `area` 메서드를 호출할 수 있습니다. 메서드 문법은 인스턴스 뒤에 점을 추가하고 메서드 이름, 괄호 및 필요한 인수를 적는 방식입니다.

`area`의 시그니처에서는 `rectangle: &Rectangle` 대신 `&self`를 사용합니다. 이는 이 메서드가 `impl Rectangle` 컨텍스트 내에 있기 때문에 Rust가 `self`의 타입이 `Rectangle`임을 알기 때문입니다. 주의할 점은 `&Rectangle`에서 사용했던 것처럼 여전히 `self` 앞에 `&`를 붙여야 한다는 것입니다. 메서드는 다른 매개변수처럼 `self`를 소유권을 넘길 수도, 불변으로 빌려올 수도, 가변으로 빌려올 수도 있습니다.

여기서는 `&self`를 선택했는데, 함수 버전에서 `&Rectangle`을 사용했던 것과 같은 이유입니다. 소유권을 넘기고 싶지 않고, 구조체의 데이터를 읽기만 하며 작성하지 않기를 원하기 때문입니다. 만약 메서드가 실행 도중 호출된 인스턴스를 변경하고 싶다면, 첫 번째 매개변수로 `&mut self`를 사용해야 합니다. `self`만을 첫 번째 매개변수로 사용하여 인스턴스의 소유권을 가져가는 메서드는 드뭅니다. 이런 방식은 메서드가 `self`를 다른 것으로 변환하는 경우, 변환 이후 호출자가 원래 인스턴스를 사용하지 않도록 방지하고 싶을 때 주로 사용됩니다.

메서드를 사용하는 주요 이점은 메서드 문법을 사용할 수 있다는 점 외에도 모든 메서드의 시그니처에서 `self`의 타입을 반복하지 않아도 된다는 점입니다. 또한, 타입 인스턴스에서 수행할 수 있는 모든 동작을 하나의 `impl` 블록에 모아 구성할 수 있기 때문에 메서드가 라이브러리의 여러 곳에 흩어져 있는 경우보다 코드 사용자들에게 더 명확한 구조를 제공합니다.

> ### `->` 연산자는 어디에 있나요?
>
> C와 C++에서는 메서드를 호출하는데 두 가지 연산자를 사용합니다. 객체에서 직접 메서드를 호출할 경우 `.`을 사용하고, 객체 포인터에서 메서드를 호출하려면 포인터를 먼저 역참조해야 하기에 `->`를 사용합니다. 다시 말하면, `object`가 포인터인 경우, `object->something()`은 `(*object).something()`과 유사합니다.
>
> Rust에는 `->` 연산자에 해당하는 것이 없습니다. 대신, Rust는 *자동 참조 및 역참조*라는 기능을 제공합니다. 메서드를 호출하는 것은 Rust에서 이러한 동작이 나타나는 몇 안 되는 경우 중 하나입니다.
>
> 작동 방식은 다음과 같습니다: `object.something()`으로 메서드를 호출하면, Rust는 자동으로 `&`, `&mut`, 또는 `*`를 추가하여 `object`가 메서드의 시그니처와 일치하도록 만듭니다. 즉, 다음 두 코드는 동일합니다:
>
> ```rust
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> 첫 번째 코드는 훨씬 더 깔끔해 보입니다. 이 자동 참조 동작은 메서드에 명확한 수신자, 즉 `self`의 타입이 있기 때문에 작동합니다. 수신자와 메서드 이름이 주어지면 Rust는 메서드가 읽기(`&self`), 변경(`&mut self`), 또는 소비(`self`) 중 어떤 동작을 하는지 확실히 알 수 있습니다. Rust가 메서드 수신자에 대해 대여를 암시적으로 처리하는 점은 소유권을 실제로 다룰 때 사용성을 높이는 중요한 요소입니다.