## 열거형 정의하기

코드에서 표현하고자 하는 상황을 살펴보고, 왜 열거형(enum)이 유용하며 이 경우 구조체(struct)보다 더 적합한지 살펴봅시다. 예를 들어, IP 주소를 다루어야 한다고 가정해봅시다. 현재 IP 주소에는 두 가지 주요 표준이 사용됩니다: 버전 4와 버전 6. 우리 프로그램이 처리하게 될 IP 주소는 이 두 가지 가능성 중 하나뿐입니다. 즉, 가능한 모든 변형을 *열거*할 수 있으며, 여기서 열거형이라는 이름이 유래합니다.

모든 IP 주소는 버전 4 또는 버전 6 중 하나일 수 있지만, 동시에 두 가지가 될 수는 없습니다. 이러한 IP 주소의 속성 때문에 열거형 데이터 구조가 적합합니다. 열거형의 값은 오직 그 변형 중 하나만 될 수 있기 때문입니다. 버전 4와 버전 6의 주소는 근본적으로 여전히 IP 주소이므로, 코드가 어떠한 형태의 IP 주소에도 적용되는 상황을 처리할 때 동일한 유형으로 취급해야 합니다.

이 개념을 코드로 표현하려면 `IpAddrKind`라는 열거형을 정의하고, IP 주소가 될 수 있는 가능한 종류인 `V4`와 `V6`을 나열하면 됩니다. 이것이 열거형의 변형입니다:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

`IpAddrKind`는 이제 코드 내 다른 곳에서 사용할 수 있는 사용자 정의 데이터 유형이 되었습니다.

### 열거형 값

`IpAddrKind`의 두 변형 각각의 인스턴스를 다음과 같이 생성할 수 있습니다:

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

열거형의 변형이 그 식별자 아래로 네임스페이스화(namespace)된다는 점에 주목하세요. 변형과 식별자 사이를 구분할 때 더블 콜론(::)을 사용합니다. 이것이 유용한 이유는 이제 `IpAddrKind::V4`와 `IpAddrKind::V6` 모두 동일한 유형인 `IpAddrKind`가 된다는 점입니다. 따라서 예를 들어, 어떤 `IpAddrKind`라도 인수로 받을 수 있는 함수를 정의할 수 있습니다:

```rust
fn route(ip_kind: IpAddrKind) {}
```

그리고 이 함수를 두 변형 중 하나로 호출할 수 있습니다:

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);