### `Option` 열거형과 null 값보다 나은 점

이전 섹션에서는 Rust의 타입 시스템을 활용하여 단순한 데이터 외에도 더 많은 정보를 프로그램에 인코딩할 수 있게 해주는 `IpAddr` 열거형에 대해 살펴보았습니다. 이번 섹션에서는 표준 라이브러리에서 정의된 또 다른 열거형인 `Option`을 사례로 다룹니다. `Option` 타입은 값이 있을 수도 있고 없을 수도 있는 매우 일반적인 시나리오를 나타내기 때문에 여러 곳에서 사용됩니다. 이 개념을 타입 시스템으로 표현하면, 컴파일러가 다뤄야 할 모든 경우를 처리했는지 검사할 수 있게 됩니다. 이는 다른 프로그래밍 언어에서 매우 흔한 버그를 방지할 수 있는 기능입니다.

프로그래밍 언어 설계는 포함할 기능뿐만 아니라 배제할 기능에 대해서도 심사숙고해야 합니다. Rust에는 많은 다른 언어에 존재하는 null 기능이 없습니다. *null*은 값이 없음을 나타내는 값입니다. null이 있는 언어에서는 변수가 항상 null 또는 null이 아닌 두 상태 중 하나로 존재할 수 있습니다.

2009년 프레젠테이션 “Null References: The Billion Dollar Mistake”에서 null을 발명한 토니 호어(Tony Hoare)는 다음과 같이 말했습니다:

> 저는 이것을 ‘10억 달러 규모의 실수’라고 부릅니다. 당시 저는 객체 지향 언어에서 참조를 위한 첫 번째 종합적인 타입 시스템을 설계하고 있었습니다. 제 목표는 컴파일러가 자동으로 검사를 수행하여 모든 참조 사용이 절대적으로 안전하도록 보장하는 것이었습니다. 하지만 null 참조를 포함시키는 유혹을 뿌리칠 수 없었습니다. 단순히 구현이 쉬웠기 때문입니다. 이 결정은 지난 40년 동안 수많은 오류, 취약성, 시스템 충돌을 일으켰고, 아마도 10억 달러에 달하는 고통과 피해를 초래했을 겁니다.

null 값의 문제는 null 값을 null이 아닌 값처럼 사용하려 하면 어떤 형태의 오류가 발생한다는 점입니다. null 또는 null이 아닌 속성이 널리 퍼져 있기 때문에 이러한 오류를 만드는 것은 매우 쉽습니다.

그러나 null이 표현하려는 개념 자체는 여전히 유용합니다. null은 어떤 이유로 인해 현재 유효하지 않거나 존재하지 않는 값을 나타냅니다.

문제는 개념 자체가 아니라 특정 구현 방식에 있습니다. 따라서 Rust에는 null이 없지만, 값을 가지고 있거나 없음을 나타내는 개념을 인코딩할 수 있는 열거형이 존재합니다. 이 열거형은 `Option<T>`이며 표준 라이브러리에 [다음과 같이 정의되어 있습니다][option]<!-- ignore -->:

[option]: https://doc.rust-lang.org/std/option/enum.Option.html

```rust
enum Option<T> {
    Some(T),
    None,
}
```

`Option<T>` 열거형은 너무 유용해서 기본 prelude에 포함되어 있습니다. 따라서 범위로 명시적으로 가져올 필요가 없습니다. 또한, 해당 variant도 포함되어 있어 `Option::` 접두어 없이 `Some`과 `None`을 직접 사용할 수 있습니다. `Option<T>` 열거형은 여전히 일반적인 열거형일 뿐이며, `Some(T)` 및 `None`은 여전히 `Option<T>` 타입의 variant입니다.

`<T>` 구문은 Rust의 기능 중 하나로, 아직 설명하지 않았던 제네릭 타입 매개변수입니다. 제네릭에 대한 자세한 내용은 "제네릭 타입, 트레이트, 그리고 라이프타임" 장에서 다룰 예정입니다. 지금은 `<T>`는 `Option` 열거형의 `Some` variant가 모든 타입의 데이터를 하나 가질 수 있다는 것을 의미한다는 것만 알면 됩니다. 숫자 타입과 문자열 타입을 `Option` 값으로 사용하는 몇 가지 예는 다음과 같습니다:

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```

`None`을 사용하는 경우, Rust에게 우리가 어떤 타입의 `Option<T>`를 사용하는지 알려줘야 합니다. 컴파일러는 `None` 값만 보고는 `Some` variant가 가질 타입을 추론할 수 없기 때문입니다.

`Some` 값을 가지고 있다면, 해당 값이 존재하며 `Some` 안에 포함되어 있다는 것을 알 수 있습니다. 반면, `None` 값을 가지고 있다면 이는 null과 같은 의미를 가집니다. 즉, 유효한 값이 없음을 나타냅니다. 그렇다면, `Option<T>`가 null보다 나은 점은 무엇일까요?

간단히 말해, `Option<T>`와 `T` (여기서 `T`는 모든 타입이 될 수 있음)는 서로 다른 타입이기 때문에, 컴파일러는 `Option<T>` 값을 마치 유효한 값인 것처럼 사용할 수 없도록 강제합니다. 예를 들어, 아래 코드는 `i8`과 `Option<i8>`을 더하려 하기 때문에 컴파일되지 않습니다:

```rust,ignore,does_not_compile
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

이 코드를 실행하면 다음과 같은 오류 메시지가 나타납니다:

```console
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ `i8 + Option<i8>`에 대한 구현이 없습니다
  |
  = help: `i8`에 대해 `Add<Option<i8>>` 트레이트가 구현되지 않았습니다
  ```

강렬하죠! 이 오류 메시지는 `i8`과 `Option<i8>`이 서로 다른 타입이기 때문에 Rust가 더하는 방법을 이해하지 못한다는 뜻입니다. Rust에서 `i8`과 같은 타입의 값을 가지면, 컴파일러는 항상 유효한 값을 가지도록 보장합니다. 우리는 null 여부를 확인하지 않고도 안전하게 진행할 수 있습니다. `Option<i8>` (또는 작업 중인 다른 타입) 값이 있는 경우에만 값이 없을 가능성을 고려해야 하며, 컴파일러는 그런 상황에서 처리 방법을 강제합니다.

즉, `Option<T>` 값을 `T`로 변환해야만 `T` 타입의 연산을 수행할 수 있습니다. 이것은 null과 관련된 가장 흔한 문제인 null이 아니라고 잘못 가정하는 것을 방지하는 데 도움이 됩니다.

null이 아닌 값을 잘못 가정하는 것에 대해 걱정하지 않아도 된다는 점은 코드에 대한 자신감을 높여줍니다. null일 수 있는 값을 가지려면 `Option<T>` 타입으로 설정하여 명시적으로 선택해야 합니다. 그런 값을 사용할 때는 null일 수 있는 경우를 명시적으로 처리해야 합니다. 반면, `Option<T>`가 아닌 타입의 값이라면 null이 아니라고 *안전하게* 가정할 수 있습니다. 이는 Rust가 null의 확산을 제한하고 코드의 안전성을 높이기 위해 의도적으로 한 설계 결정입니다.

그렇다면, `Option<T>` 타입의 값을 가지고 있을 때, 어떻게 `Some` variant 안의 값을 꺼내어 사용할 수 있을까요? `Option<T>` 열거형에는 다양한 상황에서 유용한 많은 메서드가 있습니다. 이러한 메서드는 [문서][docs]<!-- ignore -->에서 확인하실 수 있습니다. `Option<T>` 메서드에 익숙해지는 것은 Rust와 함께하는 여정에서 매우 유용할 것입니다.

[docs]: https://doc.rust-lang.org/std/option/enum.Option.html

일반적으로, `Option<T>` 값을 사용할 때는 각 variant를 처리할 코드를 작성해야 합니다. `Some(T)` 값을 가질 경우에만 실행되는 코드에서 내부의 `T` 값을 사용할 수 있습니다. `None` 값을 가질 때는 `T` 값을 사용할 수 없으며, 대신 해당 경우를 처리하는 다른 코드를 작성해야 합니다. 열거형과 함께 사용할 때 `match` 표현식은 이런 작업을 수행할 수 있는 제어 흐름 구조로, 열거형의 어느 variant를 가졌는지에 따라 다른 코드를 실행하며, 해당 코드는 매칭된 variant 내부 데이터를 사용할 수 있습니다.