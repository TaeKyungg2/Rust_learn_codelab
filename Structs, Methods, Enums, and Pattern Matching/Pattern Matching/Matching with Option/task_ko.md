### `Option<T>`와 매칭하기

이전 섹션에서는 `Option<T>`를 사용할 때 `Some` 케이스에서 내부 `T` 값을 얻고자 했습니다. 비슷한 방식으로, 우리가 `Coin` 열거형과 함께 했던 것처럼 `Option<T>`도 `match`를 사용해 다룰 수 있습니다! 동전을 비교하는 대신, 우리는 `Option<T>`의 변형을 비교합니다. 그러나 `match` 표현식이 작동하는 방식은 동일합니다.

예를 들어, `Option<i32>`를 받아 내부에 값이 있을 경우 해당 값에 1을 더하는 함수를 작성하고 싶다고 가정해봅시다. 내부에 값이 없으면 함수는 `None` 값을 반환하고 어떠한 연산도 수행하지 않아야 합니다.

다행스럽게도, `match`를 사용하면 이 함수는 매우 간단하게 작성할 수 있으며 아래 코드와 같은 형태가 될 것입니다.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

#### `Option<i32>`에 대해 `match` 표현식을 사용하는 함수

첫 번째 `plus_one` 실행을 더 자세히 살펴봅시다. 우리가 `plus_one(five)`를 호출하면, `plus_one`의 본문에서 변수 `x`는 값 `Some(5)`를 가지게 됩니다. 그런 후 우리는 각 매치 팔(arm)과 비교합니다.

```rust,ignore
None => None,
```

`Some(5)` 값은 패턴 `None`과 일치하지 않으므로, 우리는 다음 팔로 넘어갑니다.

```rust,ignore
Some(i) => Some(i + 1),
```

`Some(5)`가 `Some(i)`와 일치합니까? 네, 맞습니다! 같은 변형을 가지고 있습니다. `i`는 `Some`에 포함된 값에 바인딩되므로, `i`는 값 `5`를 갖게 됩니다. 그런 후 매치 팔 내 코드를 실행하여 `i` 값에 1을 더하고, 총합 `6`이 포함된 새로운 `Some` 값을 생성합니다.

이제 Listing 6-5에서 `plus_one`의 두 번째 호출을 고려해봅시다. `x`는 `None`입니다. `match`로 들어가 첫 번째 팔과 비교합니다.

```rust,ignore
None => None,
```

일치합니다! 더할 값이 없으므로 프로그램은 멈추고 `=>`의 오른쪽에 있는 `None` 값을 반환합니다. 첫 번째 팔이 일치했기 때문에 다른 팔은 비교하지 않습니다.

`match`와 열거형을 결합하면 많은 상황에서 유용합니다. Rust 코드에서 이 패턴을 자주 볼 수 있습니다. 열거형에 대해 `match`를 수행하여 내부 데이터를 변수에 바인딩한 다음, 이를 기반으로 코드를 실행합니다. 처음에는 약간 까다로울 수 있지만, 이에 익숙해지면 모든 언어에 있었으면 하고 바랄 정도로 편리합니다. 이는 사용자들의 인기 있는 기능 중 하나입니다.