### Catch-all 패턴과 `_` 플레이스홀더

열거형(enums)을 사용할 때, 특정 몇 개의 값에 대해 특별한 동작을 실행하고, 나머지 모든 값에 대해서는 기본 동작을 실행하도록 구현할 수 있습니다. 예를 들어, 주사위를 굴려 3이 나오면 플레이어는 이동하지 않고 새롭고 멋진 모자를 얻는 게임을 구현한다고 상상해봅시다. 7이 나오면 플레이어는 멋진 모자를 잃게 됩니다. 그리고 다른 모든 값에 대해서는 게임 보드에서 그만큼의 칸을 이동합니다. 아래는 주사위 결과 값을 랜덤으로 생성하는 대신 하드코딩했고, 나머지 로직은 실제로 구현하지 않고 함수의 골격만을 나타낸 `match` 문을 사용하여 해당 논리를 구현한 코드입니다:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

첫 번째와 두 번째 분기(arms)에서는 패턴이 각각 리터럴 값 3과 7입니다. 나머지 가능한 모든 값을 다루는 마지막 분기에서는 `other`라는 변수 이름을 패턴으로 사용합니다. `other` 분기에서 실행되는 코드는 이 변수를 `move_player` 함수에 전달하여 사용합니다.

이 코드는 컴파일됩니다. 비록 u8 타입이 가질 수 있는 모든 가능한 값을 명시적으로 나열하지 않았더라도, 마지막 패턴이 나열되지 않은 모든 값을 매칭하기 때문입니다. 이 catch-all 패턴은 `match`가 반드시 모든 경우를 다루어야 한다는 요구사항을 충족합니다. 패턴은 순서대로 평가되므로, catch-all 분기는 반드시 마지막에 위치해야 합니다. Rust는 만약 catch-all 분기 이후에 다른 분기를 추가하면, 해당 분기가 절대 매칭될 수 없기 때문에 경고를 제공합니다.

Rust에는 또한 catch-all 패턴에서 값을 사용하지 않을 때 사용할 수 있는 패턴인 `_`이 있습니다. 이 패턴은 모든 값을 매칭하지만 그 값에 바인딩되지 않습니다. 이를 통해 Rust에게 값을 사용하지 않을 것임을 알릴 수 있으며, Rust는 사용되지 않는 변수에 대해 경고하지 않습니다.

이제 규칙을 변경해 주사위에서 3이나 7이 아닌 값이 나오면 다시 굴려야 한다고 해봅시다. 이 경우에는 해당 값을 사용할 필요가 없으므로, `other`라는 이름의 변수 대신 `_`를 사용할 수 있습니다:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

이 예제 역시 모든 경우를 다룬다는 요구사항을 충족합니다. 마지막 분기에서 모든 다른 값을 명시적으로 무시했기 때문에 잊어버린 경우는 없습니다.

한 번 더 규칙을 변경해서, 3이나 7이 아닌 값에 대해서는 아무 동작도 실행하지 않도록 한다면, 해당 내용을 `_` 분기의 코드에 유닛 값(“튜플 타입” 절에서 언급한 비어 있는 튜플 타입)을 사용해 표현할 수 있습니다:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

여기서 우리는 Rust에게 이전 분기의 패턴과 일치하지 않는 다른 값을 명시적으로 사용하지 않을 것이며, 해당 경우에 실행할 코드도 없다는 것을 알리고 있습니다.

패턴과 매칭에 대해 다룰 내용은 [Rust Book의 18장][ch18-00-patterns]에서 더 자세히 설명할 예정입니다. 지금은 `if let` 구문으로 넘어가 보도록 하겠습니다. 이 구문은 `match` 표현식이 다소 장황할 때 유용할 수 있습니다.

[ch18-00-patterns]: https://github.com/rust-lang/book/blob/master/src/ch18-00-patterns.md