## 배열 타입

다중 값을 가질 수 있는 또 다른 방법은 _배열_입니다. 튜플과는 달리, 배열의 모든 요소는 같은 타입이어야 합니다. 러스트의 배열은 다른 언어의 배열과는 다릅니다. 러스트의 배열은 튜플처럼 고정된 길이를 가지고 있습니다.

러스트에서 배열에 값을 할당할 때는 값들을 쉼표로 구분된 리스트 형태로 대괄호 안에 작성합니다:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

배열은 데이터를 힙 대신 스택에 할당하고자 할 때나 항상 고정된 개수의 요소를 유지하고자 할 때 유용합니다(스택과 힙에 대해서는 4장에서 더 자세히 다룰 것입니다). 하지만 배열은 벡터 타입처럼 유연하지는 않습니다. 벡터는 표준 라이브러리가 제공하는 비슷한 컬렉션 타입으로, 크기를 증가시키거나 줄일 수 있습니다. 배열을 사용할지 벡터를 사용할지 확신이 없다면 대부분의 경우 벡터를 사용하는 것이 좋습니다. 벡터에 대해서는 8장에서 더 자세히 다룹니다.

배열을 벡터 대신 사용하고자 하는 경우의 예로, 연도 내 월의 이름을 알아야 하는 프로그램을 들 수 있습니다. 이런 프로그램에서 월을 추가하거나 제거할 가능성은 낮으므로, 항상 12개의 요소를 가지는 배열을 사용할 수 있습니다:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

배열의 타입을 작성하려면 대괄호를 사용하고, 대괄호 안에 각 요소의 타입, 세미콜론, 배열의 요소 개수를 포함시켜야 합니다. 예를 들어:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

여기서 `i32`는 각 요소의 타입입니다. 세미콜론 뒤의 숫자 `5`는 배열에 5개의 요소가 포함되어 있음을 나타냅니다.

이 방식은 배열을 초기화하는 대안 구문과 비슷합니다: 모든 요소가 동일한 값을 가지는 배열을 생성하려면 초기 값을 설정한 뒤 세미콜론과 배열의 길이를 대괄호 안에 작성할 수 있습니다. 예를 들면:

```rust
let a = [3; 5];
```

`a`라는 이름의 배열에는 총 `5`개의 요소가 들어가며, 모든 요소는 초기 값으로 `3`을 가집니다. 이는 `let a = [3, 3, 3, 3, 3];`를 작성한 것과 동일하지만, 더 간결한 표현입니다.

#### 배열 요소 접근하기

배열은 스택에 할당된 단일 메모리 청크입니다. 배열의 요소를 접근하려면 인덱스를 사용하면 됩니다. 예를 들면 다음과 같습니다:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

이 예제에서 `first`라는 변수는 `1` 값을 가지게 됩니다. 이는 배열의 인덱스 `[0]` 위치의 값입니다. `second`라는 변수는 배열의 인덱스 `[1]`에서 값 `2`를 가져오게 됩니다.

#### 잘못된 배열 요소 접근

배열의 끝을 넘어서는 요소에 접근하려면 어떤 일이 발생할까요? 예제를 다음과 같이 수정하면 컴파일은 성공하지만 실행 중 오류가 발생합니다:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

이 코드를 `cargo run` 명령어로 실행하면 다음 결과가 나타납니다:

```text
   Finished dev [unoptimized + debuginfo] target(s) in 0.05s
   Running `target/debug/Test_Rust_Project`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
```

컴파일러가 에러를 출력하지 않았더라도 프로그램은 _런타임_ 에러로 인해 성공적으로 종료되지 않았습니다. 배열의 요소에 접근할 때 러스트는 지정한 인덱스가 배열의 길이보다 작은지 확인합니다. 만약 인덱스가 배열 길이 이상이라면, 러스트는 패닉(panic)합니다.

이는 러스트의 안전성 원칙이 적용된 첫 번째 예입니다. 많은 저수준 언어에서는 이러한 검사를 수행하지 않으며, 잘못된 인덱스를 제공했을 때 유효하지 않은 메모리가 접근될 수 있습니다. 러스트는 즉시 프로그램을 종료하여 메모리 접근을 방지하면서 이러한 오류로부터 사용자를 보호합니다. 9장에서 러스트의 오류 처리를 더 자세히 다룹니다.

_러스트 프로그래밍 언어 공식 문서에서 다음 장을 참조하세요: [복합 타입](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#compound-types)_