## 변수와 가변성

간단한 변수에 대해 이야기해봅시다.

```rust
let x = 5;
```

이것은 *변수*를 생성하는 데 사용되는 `let` 문입니다. 다음은 또 다른 예입니다:

```rust
let foo = bar;
```

이 코드는 `foo`라는 새로운 변수를 생성하고 `bar` 변수 값에 이를 연결합니다.

러스트에서 변수는 기본적으로 불변(immutable)입니다. 이는 러스트가 제공하는 안전성과 쉬운 동시성을 활용할 수 있도록 여러분의 코드를 작성하게 만드는 여러 가지 권장 사항 중 하나입니다. 하지만 여전히 변수를 가변(mutable)하게 만들 수도 있습니다. 러스트가 왜 불변성을 우선시하도록 권장하고, 왜 때로는 이를 벗어나야 할 때가 있는지 살펴봅시다.

변수가 불변일 때, 한 번 이름에 값을 바인딩하면 해당 값을 변경할 수 없습니다. `main.rs` 파일을 살펴보면, 해당 코드가 아직 컴파일되지 않는 것을 볼 수 있습니다:

```rust
fn main() {
       let x = 5;
       println!("x의 값은: {}", x);
       x = 6;
       println!("x의 값은: {}", x);
   }
```

**Run** 버튼을 클릭하여 프로그램을 실행하세요.

다음과 같은 오류 메시지를 받을 것입니다:

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         처음으로 `x`에 값을 할당한 위치
  |         도움말: 이 바인딩을 가변으로 설정하려면: `mut x`
3 |     println!("x의 값은: {}", x);
4 |     x = 6;
  |     ^^^^^ 불변 변수에 두 번 할당할 수 없습니다
```

이 예제는 컴파일러가 여러분이 프로그램에서 오류를 찾도록 어떻게 도와주는지 보여줍니다. 컴파일러 오류가 때로는 좌절감을 줄 수 있지만, 이는 프로그램이 안전하게 원하는 작업을 아직 수행하지 못하고 있다는 것을 의미할 뿐입니다. 이는 여러분이 좋은 프로그래머가 아니라는 뜻이 아닙니다! 숙련된 러스트 사용자들(Rustaceans)도 여전히 컴파일러 오류를 만날 수 있습니다.

오류 메시지는 오류의 원인이, 여러분이 `불변 변수 x에 두 번 할당할 수 없다`는 것임을 나타냅니다. 이는 불변 변수 `x`에 두 번째 값을 할당하려 했기 때문입니다.

우리가 한때 불변으로 지정한 값을 변경하려고 할 때 컴파일 시점에 오류를 받는 것이 중요한 이유는 바로 이런 상황이 버그로 이어질 수 있기 때문입니다. 코드의 한 부분이 값이 절대 변경되지 않을 것이라 가정하고 작동하는데, 코드의 다른 부분이 해당 값을 변경하면 첫 번째 부분은 설계된 대로 작동하지 않을 수 있습니다. 특히, 두 번째 코드가 값이 가끔만 변경되도록 작성되었다면, 이러한 버그의 원인을 사후에 추적하기 어려울 수 있습니다.

러스트에서 컴파일러는 여러분이 값이 변경되지 않을 것이라고 명시할 때, 실제로 값이 변경되지 않도록 보장합니다. 즉, 코드를 읽고 작성할 때 값이 어떻게 어디서 변경될지 추적할 필요가 없습니다. 따라서 여러분의 코드가 더 쉽게 파악할 수 있는 방식이 됩니다.

하지만 가변성은 매우 유용할 수 있습니다. 변수는 기본적으로 불변일 뿐이며, 변수 이름 앞에 `mut`을 추가하면 가변하게 만들 수 있습니다. 이는 값이 변경될 수 있도록 허용할 뿐만 아니라 코드의 미래 독자들에게 이 변수가 나중에 코드의 다른 부분에서 변경될 것임을 의도적으로 전달합니다.

예를 들어, _src/main.rs_ 파일을 다음과 같이 변경해 보세요:

```rust

fn main() {
    let mut x = 5;
    println!("x의 값은: {}", x);
    x = 6;
    println!("x의 값은: {}", x);
}
```

이제 프로그램을 실행하면 다음과 같은 결과를 보게 됩니다:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
x의 값은: 5
x의 값은: 6
```

`mut`을 사용했을 때, `x`가 `5`에서 `6`으로 값이 변경되도록 허용됩니다. 경우에 따라서는 변수를 가변하게 만드는 것이 모든 변수를 불변으로 유지하는 것보다 더 편리하게 코드를 작성할 수 있는 상황도 있습니다.

버그 방지 외에도 고려해야 할 여러 트레이드오프(trade-off)가 있습니다. 예를 들어, 대형 데이터 구조를 사용하는 경우, 인스턴스를 제자리에서 변경하는 것이 새로 할당된 인스턴스를 복사하고 반환하는 것보다 더 빠를 수 있습니다. 작은 데이터 구조의 경우, 새 인스턴스를 만들고 더 함수형 프로그래밍 스타일로 작성하는 것이 이해하기 더 쉬울 수 있으며, 그러한 명확성을 위해 성능 저하를 감수할 가치가 있을지도 모릅니다.

_러스트 프로그래밍 언어 책의 [Variables and Mutability](https://doc.rust-lang.org/stable/book/ch03-01-variables-and-mutability.html) 장을 참조하세요._

이제 연습 과제를 진행해 봅시다.