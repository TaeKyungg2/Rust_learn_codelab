## 배열을 for로 반복하기

`while` 구문을 사용하여 배열과 같은 컬렉션의 요소를 반복할 수 있습니다. 예를 들어, 다음 코드를 살펴보겠습니다:

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
##### while 루프를 사용하여 컬렉션의 각 요소를 반복하는 예시

여기서 코드는 배열의 요소를 순차적으로 셉니다. 인덱스 `0`부터 시작하여 배열의 마지막 인덱스에 도달할 때까지 반복합니다(즉, `index < 5`가 더 이상 참이 아닐 때). 이 코드를 실행하면 배열의 모든 요소가 출력됩니다:

```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

예상한 대로, 다섯 개의 배열 값이 모두 터미널에 나타납니다. 인덱스 `index`가 언젠가 `5`에 도달하더라도, 루프는 배열에서 여섯 번째 값을 가져오려고 시도하기 전에 실행을 멈춥니다.

하지만 이 접근 방식은 오류가 발생하기 쉬운데, 인덱스 길이가 잘못될 경우 프로그램이 패닉(panic) 상태가 될 수 있습니다. 또한 컴파일러가 루프를 반복할 때마다 조건을 검사하는 런타임 코드를 추가하기 때문에 성능이 느려집니다.

더 간결한 대안으로, `for` 루프를 사용하여 컬렉션의 각 항목에 대해 코드를 실행할 수 있습니다. `for` 루프는 다음과 같이 보입니다:

```rust
fn main() {
    let arr = [10, 20, 30, 40, 50];

    for element in arr {
        println!("the value is: {}", element);
    }
}
```
##### for 루프를 사용하여 컬렉션의 각 요소를 반복하는 예시

이 코드를 실행하면 이전 코드 스니펫과 동일한 출력이 표시됩니다. 더 중요한 점은 이제 코드의 안전성을 높이고 배열 끝을 초과하거나 충분히 반복하지 않아 일부 항목을 놓치는 등의 버그가 발생할 가능성을 제거했다는 점입니다.

예를 들어 이전 코드 스니펫에서 `a` 배열의 정의를 네 개의 요소로 변경했지만, `while index < 4`로 조건을 수정하는 것을 잊었다면 코드가 패닉 상태가 될 것입니다. 그러나 `for` 루프를 사용하면 배열 값의 수를 변경하더라도 다른 코드를 수정할 필요가 없습니다.