### 문자열 업데이트하기

`String`은 `Vec<T>`의 내용처럼 크기가 커지고 내용이 변경될 수 있습니다. 데이터를 추가하면 크기가 커지고, `+` 연산자나 `format!` 매크로를 사용해 `String` 값들을 편리하게 연결(concatenate)할 수도 있습니다.

#### `push_str`와 `push`로 문자열 추가하기

`push_str` 메서드를 사용하여 문자열 슬라이스를 추가하면, 아래 코드 스니펫에서처럼 `String`의 크기를 키울 수 있습니다.

```rust
    let mut s = String::from("foo");
    s.push_str("bar");
```

##### push_str 메서드를 사용해 String에 문자열 슬라이스 추가하기 예제

이 두 줄의 코드 이후에 `s`는 `foobar`를 포함하게 됩니다. `push_str` 메서드는 문자열 슬라이스를 매개변수로 받습니다. 이는 매개변수의 소유권을 반드시 가져가지 않아도 되기 때문입니다. 예를 들어, 아래 코드 스니펫에서는 `s2`의 내용을 `s1`에 추가한 후에도 `s2`를 계속 사용할 수 있습니다.

```rust
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
```

##### String에 내용을 추가한 후 문자열 슬라이스 사용하기

만약 `push_str` 메서드가 `s2`의 소유권을 가져갔다면, 마지막 줄에서 `s2`의 값을 출력할 수 없게 되었을 것입니다. 그러나 이 코드는 기대한 대로 작동합니다!

`push` 메서드는 단일 문자를 매개변수로 받아 `String`에 추가합니다. 아래 코드는 `push` 메서드를 사용하여 문자 _l_을 `String`에 추가하는 방법을 보여줍니다.

```rust
    let mut s = String::from("lo");
    s.push('l');
```

##### push를 사용해 String 값에 한 글자를 추가하기

이 코드의 결과로 `s`에는 `lol`이 포함됩니다.

#### `+` 연산자와 format! 매크로로 문자열 연결하기

종종 두 개의 기존 문자열을 결합하고 싶을 때가 있습니다. 그 중 하나는 아래와 같이 `+` 연산자를 사용하는 방법입니다.

```rust
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // 여기서 s1은 이동되어 더 이상 사용할 수 없습니다
```

##### + 연산자를 사용하여 두 String 값을 새 String 값으로 결합하기

이 코드의 결과로, 문자열 `s3`에는 `Hello, world!`가 포함됩니다. `s1`이 추가 후 더 이상 유효하지 않은 이유와 `s2`를 참조로 사용한 이유는 `+` 연산자를 사용할 때 호출되는 메서드의 시그니처 때문입니다. `+` 연산자는 `add` 메서드를 사용하며, 이 메서드의 시그니처는 대략 다음과 같습니다:

```rust
    fn add(self, s: &str) -> String {
```

이것이 표준 라이브러리에 있는 정확한 시그니처는 아니지만, 여기서는 일반적인 타입 대신 구체적인 타입을 대입한 형태를 보여줍니다. 우리가 `String` 값으로 이 메서드를 호출할 때 실제로 이런 일이 벌어집니다. 우리는 "제네릭 타입, 트레잇, 수명" 장에서 제네릭에 대해 논의할 것입니다. 이 시그니처를 보면 `+` 연산자의 복잡한 부분을 이해할 수 있는 힌트를 얻을 수 있습니다.

첫 번째로, `s2`에는 `&`가 붙어 있습니다. 이는 `add` 함수의 `s` 매개변수 때문에 두 번째 문자열의 _참조_를 첫 번째 문자열에 추가하고 있음을 의미합니다. `add` 함수에는 `&str`만 추가할 수 있고, 두 개의 `String`을 직접 추가할 수는 없습니다. 그런데, "두 String 값을 새 String 값으로 결합하기" 목록에서는 타입이 `&s2`이며 이는 `&String`이지 `&str`이 아닙니다. 그렇다면 왜 컴파일이 될까요?

우리가 `add`를 호출할 때 컴파일러는 `&String` 인수를 `&str`로 _강제 변환_합니다. 즉, `&s2`를 `&s2[..]`로 변환합니다. 우리는 15장에서 이러한 Deref 강제 변환에 대해 더 깊이 다룰 것입니다. `add` 메서드가 `s` 매개변수의 소유권을 가져가지 않기 때문에, 이 작업 이후에도 `s2`는 유효한 `String`으로 남아 있습니다.

두 번째로, 시그니처에서 `self`에 `&`가 붙어 있지 않아 `add`는 `self`의 소유권을 가져갑니다. 이는 "두 String 값을 새 String 값으로 결합하기" 목록의 `s1`이 `add` 호출로 이동하며 이후 유효하지 않게 됨을 의미합니다. 따라서, `let s3 = s1 + &s2;`는 두 문자열을 복사해 새 문자열을 만드는 것처럼 보이지만, 실제로는 `s1`의 소유권을 가져가고 `s2`의 내용을 복사해 추가한 다음 결과의 소유권을 반환합니다. 말하자면, 많은 복사를 하는 것처럼 보이지만, 구현은 복사보다 효율적입니다.

여러 문자열을 연결해야 할 경우, `+` 연산자의 동작은 다소 비효율적입니다:

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
```

이 시점에서 `s`는 `tic-tac-toe`를 담고 있습니다. 그러나 모든 `+`와 `"` 문자들 때문에 코드의 의도를 파악하기가 어렵습니다. 더 복잡한 문자열 결합 작업에서는 `format!` 매크로를 사용할 수 있습니다:

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
```

이 코드 역시 `s`를 `tic-tac-toe`로 설정합니다. `format!` 매크로는 `println!`과 동일한 방식으로 작동하나, 화면에 출력하는 대신 내용을 가진 `String`을 반환합니다. `format!`을 사용하는 버전은 가독성이 더 좋고, 어떠한 매개변수의 소유권도 가져가지 않습니다.