### 새로운 벡터 생성하기

새로운 빈 벡터를 생성하기 위해, 아래 코드에서 보이는 것처럼 `Vec::new` 함수를 호출할 수 있습니다.

```rust
    let v: Vec<i32> = Vec::new();
```

#### i32 타입 값을 저장할 새로운 빈 벡터 생성

여기서 타입 주석(type annotation)이 추가된 것을 주목하세요. 이 벡터에 아무 값도 삽입하지 않았기 때문에, Rust는 우리가 어떤 종류의 요소를 저장하려고 하는지 알 수 없습니다. 이는 중요한 점입니다. 벡터는 제네릭을 사용하여 구현됩니다. 제네릭을 사용하여 사용자가 정의한 타입을 다루는 방법은 "제네릭 타입, 트레이트 및 라이프타임" 챕터에서 다룰 예정입니다. 지금은 표준 라이브러리에서 제공하는 `Vec<T>` 타입이 모든 타입을 저장할 수 있으며, 특정 벡터가 특정 타입을 가지는 경우에는 타입이 꺾쇠 괄호 안에 명시된다는 것을 알아두세요. 위 코드에서는 `v`라는 `Vec<T>`가 `i32` 타입의 요소를 저장할 것이라고 Rust에 알려주었습니다.

더 현실적인 코드에서, 값을 삽입하면 Rust는 당신이 저장하려는 값의 타입을 종종 추론할 수 있습니다. 그래서 이런 타입 주석은 거의 필요하지 않습니다. 초기 값을 가진 `Vec<T>`를 생성하는 것이 더 일반적이며, Rust는 이를 편리하게 하기 위해 `vec!` 매크로를 제공합니다. 이 매크로는 주어진 값을 저장하는 새로운 벡터를 생성합니다. 아래 코드에서는 `1`, `2`, `3`이라는 값을 저장하는 새로운 `Vec<i32>`를 생성합니다. 정수 타입은 `i32`인데, 이는 "일반 프로그래밍 개념" 장의 "데이터 타입" 섹션에서 논의했듯이 기본 정수 타입이기 때문입니다.

```rust
    let v = vec![1, 2, 3];
```

#### 값을 포함하는 새로운 벡터 생성

초기 `i32` 값들을 제공했기 때문에, Rust는 `v`의 타입이 `Vec<i32>`라는 것을 추론할 수 있으며 타입 주석은 필요하지 않습니다. 이제 벡터를 수정하는 방법을 살펴보겠습니다.