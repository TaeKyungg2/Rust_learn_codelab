### 열거형(enum)을 사용하여 다양한 유형 저장하기

이 장의 시작에서 벡터는 동일한 유형의 값만 저장할 수 있다고 언급했습니다. 이는 여러 유형의 항목을 목록으로 저장해야 할 필요성이 있을 때 불편할 수 있습니다. 다행히 열거형의 변형들은 동일한 열거형 타입 아래에 정의되므로, 벡터에 서로 다른 유형의 요소를 저장해야 할 때 열거형을 정의하고 사용할 수 있습니다!

예를 들어, 스프레드시트의 한 행에서 값을 가져오려 하는데, 그 행의 일부 열은 정수를, 일부는 부동소수점 숫자를, 일부는 문자열을 포함하는 경우를 생각해봅시다. 우리는 각기 다른 값의 유형을 담을 수 있는 열거형을 정의할 수 있고, 그 결과 모든 열거형 변형들은 동일한 유형, 즉 열거형의 타입으로 간주됩니다. 그런 다음 해당 열거형을 담는 벡터를 생성할 수 있으며, 궁극적으로 서로 다른 유형을 저장할 수 있습니다. 이를 아래에 예제로 보여주었습니다.

```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```

#### 하나의 벡터에서 다양한 유형의 값을 저장하기 위한 열거형 정의하기

Rust는 컴파일 시점에 벡터에 어떤 유형이 포함될지를 알아야만 각 요소를 저장하기 위해 힙에서 필요한 메모리를 정확히 설정할 수 있습니다. 또 다른 장점은 이 벡터에 허용되는 유형을 명확히 할 수 있다는 점입니다. 만약 Rust가 벡터가 아무 유형이나 저장하는 것을 허용했다면, 벡터의 요소에 대해 수행되는 연산에서 하나 이상의 유형이 오류를 유발할 가능성이 있었을 것입니다. 열거형과 `match` 표현식을 사용하면 모든 가능한 경우가 처리되었음을 Rust가 컴파일 시점에 보장하도록 만들 수 있습니다. 이는 "열거형" 장에서 다룬 내용입니다.

프로그램을 작성할 때 런타임에 벡터에 저장될 유형의 전체 집합을 모른다면, 열거형 기법은 작동하지 않을 수 있습니다. 대신, Chapter 17에서 다룰 트레이트 객체(trait object)를 사용할 수 있습니다. 해당 내용은 [Rust 책][book]에서 다룰 예정입니다.

이제 벡터를 사용하는 몇 가지 일반적인 방법을 논의했으니, 표준 라이브러리에서 `Vec<T>`에 대해 정의된 다양한 유용한 메서드를 확인하기 위해 [API 문서][vec-api]를 검토하세요. 예를 들어, `push` 외에도 마지막 요소를 제거하고 반환하는 `pop` 메서드도 있습니다.

[vec-api]: https://doc.rust-lang.org/std/vec/struct.Vec.html  
[book]: https://doc.rust-lang.org/stable/book/