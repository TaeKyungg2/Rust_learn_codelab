### 벡터 요소 읽기 

이제 벡터를 생성, 업데이트, 삭제하는 방법을 알게 되었으니, 그 내용을 읽는 방법을 배우는 것이 다음 단계입니다. 벡터에 저장된 값을 참조하는 방법은 두 가지가 있습니다. 예제에서는 이러한 함수가 반환하는 값의 타입을 명시하여 추가로 명확성을 제공하고 있습니다.

아래 코드는 벡터의 값을 접근하는 두 가지 방법, 즉 인덱싱 구문 또는 `get` 메서드를 보여줍니다.

```rust
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("세 번째 요소는 {}", third);

    match v.get(2) {
        Some(third) => println!("세 번째 요소는 {}", third),
        None => println!("세 번째 요소가 존재하지 않습니다."),
    }
```

#### 인덱싱 구문 또는 get 메서드를 사용하여 벡터의 항목에 접근하기 

여기에서 두 가지 세부 사항이 중요합니다. 첫째, 인덱스 값 `2`를 사용하여 세 번째 요소를 가져옵니다. 벡터는 숫자로 인덱싱되며, 인덱스는 0부터 시작합니다. 둘째, 세 번째 요소를 가져오는 두 가지 방법이 있습니다. `&`와 `[]`를 사용하여 참조를 얻거나, 인덱스를 인수로 전달하여 `get` 메서드를 사용하는 경우 `Option<&T>`를 반환합니다.

러스트는 요소를 참조하기 위한 두 가지 방법을 제공하여, 벡터에 해당 인덱스에 요소가 없는 경우 프로그램이 어떻게 동작할지 선택할 수 있도록 합니다. 예를 들어, 다음과 같이 다섯 개의 요소를 가진 벡터가 있을 때 인덱스 100의 요소를 접근하려고 시도하면 프로그램이 어떻게 동작하는지 확인해 보겠습니다.

```rust,should_panic,panics
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
```

#### 다섯 개의 요소를 가진 벡터에서 인덱스 100의 요소에 접근하려는 시도

이 코드를 실행하면, 첫 번째 `[]` 메서드가 존재하지 않는 요소를 참조하기 때문에 프로그램이 패닉(panic)을 일으킵니다. 이 방법은 벡터의 끝을 넘어선 요소에 접근하려고 할 때 프로그램이 충돌(crash)하도록 하고 싶을 때 가장 적합합니다.

`get` 메서드가 벡터 범위를 벗어난 인덱스를 받으면 패닉을 일으키지 않고 `None`을 반환합니다. 벡터의 범위를 벗어난 요소에 접근하는 일이 정상적인 상황에서 가끔 발생할 수 있는 경우라면 이 메서드를 사용하는 것이 좋습니다. 그런 경우 코드에 `Some(&element)` 또는 `None`을 처리할 로직을 포함하면 됩니다. 이는 "열거형(Enums)" 장에서 논의되었던 내용과 같습니다. 예를 들어, 인덱스가 사용자가 숫자를 입력한 값에서 올 수 있습니다. 사용자가 실수로 너무 큰 숫자를 입력하고 프로그램이 `None` 값을 받으면, 현재 벡터에 몇 개의 항목이 있는지를 사용자에게 알려주고 유효한 값을 다시 입력할 기회를 제공할 수 있습니다. 이는 단순히 오타로 인해 프로그램이 충돌하는 것보다 훨씬 사용자 친화적입니다!