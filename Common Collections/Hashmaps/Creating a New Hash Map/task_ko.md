### 새로운 해시 맵 생성하기

`new`를 사용하여 빈 해시 맵을 생성하고 `insert`로 요소를 추가할 수 있습니다. 아래 코드에서는 이름이 Blue와 Yellow인 두 팀의 점수를 추적합니다. Blue 팀은 처음에 10점을 가지며, Yellow 팀은 처음에 50점을 가집니다.

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
```

#### 새로운 해시 맵 생성 및 키와 값 삽입하기

표준 라이브러리의 collections 부분에서 `HashMap`을 먼저 `use` 해야 한다는 점을 유의하세요. 세 가지 일반적인 컬렉션 중에서 해시 맵은 가장 적게 사용되므로 프렐루드에서 자동으로 범위 내로 가져오는 기능에 포함되지 않습니다. 또한 해시 맵은 표준 라이브러리에서 지원이 적습니다. 예를 들어, 벡터와 달리 해시 맵을 구성하는 내장 매크로는 없습니다.

벡터와 마찬가지로 해시 맵도 데이터를 힙에 저장합니다. 이 `HashMap`은 키로 `String` 타입을 사용하고 값으로는 `i32` 타입을 사용합니다. 벡터와 마찬가지로 해시 맵도 동일한 유형을 가지고 있는 동질적(homogeneous) 데이터 구조입니다. 즉, 모든 키는 동일한 타입이어야 하고, 모든 값도 동일한 타입이어야 합니다.

해시 맵을 구성하는 또 다른 방법은 반복자(iterator)와 튜플의 벡터에 대해 `collect` 메서드를 사용하는 것입니다. 각 튜플은 키와 해당 값을 포함합니다. 반복자와 관련 메서드에 대해서는 "반복자 및 클로저" 장의 “반복자” 섹션에서 더 자세히 다룰 예정입니다. `collect` 메서드는 데이터 모음을 다양한 컬렉션 타입으로 모을 수 있으며, `HashMap`도 이에 포함됩니다. 예를 들어 팀 이름과 초기 점수가 각각 별도의 벡터에 있다면, `zip` 메서드를 사용하여 "Blue"와 10이 연관된 튜플 벡터를 생성할 수 있습니다. 그런 다음, 아래 코드에 나와 있는 것처럼 그 튜플 벡터를 `collect` 메서드로 해시 맵으로 변환할 수 있습니다.

```rust
    use std::collections::HashMap;

    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    let mut scores: HashMap<_, _> =
        teams.into_iter().zip(initial_scores.into_iter()).collect();
```

#### 팀 리스트와 점수 리스트에서 해시 맵 생성하기

여기서 `HashMap<_, _>` 타입 애너테이션이 필요한 이유는 `collect` 메서드를 사용해 여러 다른 데이터 구조로 모을 수 있기 때문에 Rust는 명시적으로 지정하지 않으면 어떤 데이터 구조로 모을지 알 수 없기 때문입니다. 하지만 키와 값 타입의 매개변수에 대해 밑줄(_)을 사용하면, Rust는 벡터 데이터 타입을 기반으로 해시 맵이 포함해야 하는 타입을 추론할 수 있습니다. 위 코드에서 키 타입은 `String`이고 값 타입은 `i32`가 됩니다. 이는 이 섹션의 첫 번째 코드 목록에서와 동일한 타입입니다.