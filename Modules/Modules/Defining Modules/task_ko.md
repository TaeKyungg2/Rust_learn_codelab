## 모듈 정의로 범위와 비공개 설정 제어

_모듈_은 크레이트 내 코드를 그룹으로 조직해 가독성을 높이고 재사용을 쉽게 만들어줍니다. 또한, 모듈은 항목의 _비공개성_도 제어합니다. 비공개성은 항목이 외부 코드에서 사용할 수 있는지(공개) 또는 단순히 내부 구현 세부사항으로만 존재하여 외부에서 접근할 수 없는지(비공개)를 결정합니다.

예제로, 레스토랑의 기능을 제공하는 라이브러리 크레이트를 작성해 보겠습니다. 함수의 서명을 정의하되, 실제로 레스토랑 기능을 구현하기보다는 코드 조직화에 집중하기 위해 함수 본문은 비워 두겠습니다.

레스토랑 업계에서는 레스토랑의 일부를 _프론트 오브 하우스(front of house)_와 _백 오브 하우스(back of house)_로 나눕니다. 프론트 오브 하우스는 고객이 있는 곳으로, 이곳에서는 안내원이 고객을 자리로 안내하고, 서버가 주문 및 결제를 받고, 바텐더가 음료를 만듭니다. 백 오브 하우스는 주방장이나 요리사가 주방에서 일하며, 설거지를 하거나 매니저가 행정 업무를 처리하는 곳입니다.

실제 레스토랑 방식과 동일하게 크레이트를 구조화하려면 함수를 중첩된 모듈로 구성할 수 있습니다. `cargo new --lib restaurant` 명령어로 `restaurant`라는 새 라이브러리를 생성한 다음, 아래 예제의 코드를 _src/lib.rs_에 넣어 모듈과 함수 서명을 정의하십시오.

```rust
    mod front_of_house {
        mod hosting {
            fn add_to_waitlist() {}

            fn seat_at_table() {}
        }

        mod serving {
            fn take_order() {}

            fn serve_order() {}

            fn take_payment() {}
        }
    }
```

##### 다른 모듈과 함수를 포함하는 front_of_house 모듈

`mod` 키워드를 사용하여 모듈을 정의하며, 모듈 이름(이 경우 `front_of_house`)을 지정하고 중괄호로 모듈 본문을 감싸줍니다. 모듈 안에는 다른 모듈을 포함할 수 있으며, 위 코드처럼 `hosting`과 `serving` 모듈이 그 예입니다. 모듈에는 구조체(struct), 열거형(enum), 상수(constant), 트레잇(trait) 또는 위 코드 조각처럼 함수 등의 정의도 포함될 수 있습니다.

모듈을 사용하면 연관된 정의를 함께 그룹화하고, 그룹의 관련성을 이름으로 명시할 수 있습니다. 이 코드를 사용하는 프로그래머는 그룹별로 코드를 탐색할 수 있으므로 원하는 정의를 더 쉽게 찾을 수 있습니다. 또한, 새로운 기능을 추가하는 프로그래머는 프로그램을 체계적으로 유지하기 위해 새로운 코드를 넣어야 할 위치를 알고 있습니다.

앞서 우리는 _src/main.rs_와 _src/lib.rs_ 파일을 _크레이트 루트_라고 언급했는데, 그 이름의 이유는 이 두 파일의 내용이 크레이트 모듈 구조의 루트에 해당하는 `crate`라는 이름의 모듈을 형성하기 때문입니다. 이를 _모듈 트리_라고 부릅니다.  

아래는 위 코드 조각 구조의 모듈 트리를 나타냅니다.

    crate
     └── front_of_house
         ├── hosting
         │   ├── add_to_waitlist
         │   └── seat_at_table
         └── serving
             ├── take_order
             ├── serve_order
             └── take_payment

##### 모듈 트리

이 트리는 일부 모듈이 다른 모듈 내부에 중첩되어 있다는 것을 보여줍니다(_예: `hosting`은 `front_of_house` 내부에 중첩_). 트리는 또한 일부 모듈이 서로 _형제 관계_에 있다는 것도 나타내며(_예: `hosting`과 `serving`은 모두 `front_of_house` 안에 정의됨_), 가족 은유를 이어가자면, 모듈 A가 모듈 B 내에 포함되어 있다면 모듈 A를 모듈 B의 _자식_이라고 하고, 모듈 B를 모듈 A의 _부모_라고 말합니다. 전체 모듈 트리는 암시적으로 `crate`라는 이름의 모듈 하위에 루트화되어 있는 것을 확인할 수 있습니다.

모듈 트리는 컴퓨터의 파일 시스템 내 디렉터리 트리를 떠올리게 합니다. 이는 매우 적합한 비유입니다! 파일 시스템의 디렉터리처럼, 모듈을 사용하여 코드를 체계적으로 구성할 수 있습니다. 디렉터리의 파일처럼, 우리는 모듈을 찾을 수 있는 방법이 필요합니다.

_다음 장에서 더 많은 정보를 확인할 수 있습니다: [범위와 비공개 설정 제어를 위한 모듈 정의](https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html)_