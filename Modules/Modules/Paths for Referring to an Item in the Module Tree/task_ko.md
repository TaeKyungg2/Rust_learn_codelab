## 모듈 트리에서 항목을 참조하기 위한 경로

Rust에서 모듈 트리 내에서 항목을 찾는 위치를 지정하려면, 파일 시스템을 탐색할 때 경로를 사용하는 것과 동일한 방식으로 _경로(path)_ 를 사용합니다. 함수를 호출하려면 해당 함수의 경로를 알아야 합니다.

_경로_ 는 두 가지 형태를 가질 수 있습니다:

*   _절대 경로(absolute path)_ 는 크레이트 루트에서 시작하며 크레이트 이름이나 `crate` 리터럴을 사용합니다.
*   _상대 경로(relative path)_ 는 현재 모듈에서 시작하며 `self`, `super` 또는 현재 모듈의 식별자를 사용합니다.

절대 경로와 상대 경로는 모두 이중 콜론(`::`)으로 구분된 하나 이상의 식별자가 이어집니다.

이전 과제의 첫 번째 코드 스니펫 예제로 돌아가 봅시다. `add_to_waitlist` 함수를 호출하려면 어떻게 해야 할까요? 이는 곧 `add_to_waitlist` 함수의 경로가 무엇인지 묻는 것과 같습니다. 아래 코드 스니펫에서는 몇 가지 모듈과 함수를 제거하여 코드를 단순화했습니다. 크레이트 루트에 정의된 새 함수 `eat_at_restaurant`에서 `add_to_waitlist` 함수를 호출하는 두 가지 방법을 보여줍니다. `eat_at_restaurant` 함수는 라이브러리 크레이트의 공용 API의 일부이므로 `pub` 키워드로 표시합니다. "`pub` 키워드를 사용한 경로 공개" 섹션에서 `pub`에 대해 더 자세히 다룰 것입니다. 이 예제는 아직 컴파일되지 않으니, 이유는 조금 있다가 설명하겠습니다.

```rust
    mod front_of_house {
        mod hosting {
            fn add_to_waitlist() {}
        }
    }

    pub fn eat_at_restaurant() {
        // 절대 경로
        crate::front_of_house::hosting::add_to_waitlist();

        // 상대 경로
        front_of_house::hosting::add_to_waitlist();
    }
```

##### 절대 경로와 상대 경로를 사용하여 add_to_waitlist 함수 호출하기

`eat_at_restaurant`에서 첫 번째로 `add_to_waitlist` 함수를 호출할 때, 절대 경로를 사용합니다. `add_to_waitlist` 함수는 `eat_at_restaurant`과 동일한 크레이트에 정의되어 있으므로, 절대 경로를 시작할 때 `crate` 키워드를 사용할 수 있습니다.

`crate` 다음에 연속된 모듈들을 포함하여 `add_to_waitlist`로 향할 때까지 나열합니다. 동일한 구조를 가진 파일 시스템을 상상해보면, 우리는 `/front_of_house/hosting/add_to_waitlist` 경로를 지정해 `add_to_waitlist` 프로그램을 실행할 것입니다. 크레이트 루트에서 시작하기 위해 `crate` 이름을 사용하는 것은 쉘에서 파일 시스템 루트에서 시작하기 위해 `/`를 사용하는 것과 같습니다.

`eat_at_restaurant`에서 두 번째로 `add_to_waitlist`를 호출할 때는 상대 경로를 사용합니다. 경로는 모듈 트리에서 `eat_at_restaurant`과 동일한 레벨에 정의된 모듈 이름인 `front_of_house`로 시작합니다. 파일 시스템에 비유하자면, 이 경로는 `front_of_house/hosting/add_to_waitlist`를 사용하는 것과 같습니다. 이름으로 경로를 시작한다는 것은 경로가 상대적이라는 것을 의미합니다.

절대 경로와 상대 경로 중 무엇을 사용할지 결정하는 것은 프로젝트에 따라 달라집니다. 이 결정은 항목 정의 코드와 해당 항목을 사용하는 코드가 독립적으로 이동할 가능성이 높은지 여부에 따라 달라져야 합니다. 예를 들어, `front_of_house` 모듈과 `eat_at_restaurant` 함수를 `customer_experience`라는 이름의 모듈로 이동하면 `add_to_waitlist`에 대한 절대 경로를 업데이트해야 하지만, 상대 경로는 여전히 유효할 것입니다. 그러나 `eat_at_restaurant` 함수를 별도로 `dining`이라는 이름의 모듈로 이동하면 `add_to_waitlist` 호출에 대한 절대 경로는 동일하게 유지되지만, 상대 경로는 업데이트해야 합니다. 우리는 절대 경로를 지정하는 것을 선호합니다. 왜냐하면 코드 정의와 항목 호출이 서로 독립적으로 이동할 가능성이 더 높기 때문입니다.

위 코드 스니펫을 컴파일하려고 시도해 보겠습니다. 아직 컴파일이 되지 않는 이유를 알아봅시다! 아래 코드 스니펫은 우리가 얻게 될 오류를 보여줍니다.

```text
Compiling Test_Rust_Project v0.1.0
error[E0603]: module `hosting` is private
 --> src/main.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --> src/main.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^
```

##### 위 예제의 코드 빌드 시 발생하는 컴파일 오류

오류 메시지는 `hosting` 모듈이 비공개 상태(private)라고 말합니다. 즉, 우리는 `hosting` 모듈과 `add_to_waitlist` 함수에 대한 올바른 경로를 가지고 있지만, Rust는 비공개 섹션에 대한 접근 권한이 없어 사용할 수 없습니다.

모듈은 코드를 구성하는 데에만 유용한 것이 아닙니다. Rust의 _개인정보 경계_(privacy boundary)를 정의하기도 합니다. 이는 외부 코드가 알거나 호출하거나 의존할 수 없는 구현 세부사항을 캡슐화하는 선입니다. 따라서 함수나 구조체와 같은 항목을 비공개로 유지하려면 모듈에 넣으면 됩니다.

Rust에서 개인정보 보호 방식은 기본적으로 모든 항목(함수, 메서드, 구조체, 열거형, 모듈, 상수)이 비공개 상태라는 것입니다. 상위 모듈의 항목은 하위 모듈 내 비공개 항목을 사용할 수 없지만, 하위 모듈의 항목은 상위 조상 모듈 내의 항목을 사용할 수 있습니다. 이 이유는 하위 모듈이 구현 세부사항을 감싸고 숨기지만, 하위 모듈은 자신이 정의된 컨텍스트를 볼 수 있기 때문입니다. 레스토랑 비유를 계속 들자면, 개인정보 규칙은 레스토랑 고객에게는 비공개로 유지되는 백오피스와 같습니다. 하지만 관리자는 자신이 운영하는 레스토랑 내 모든 것을 보고 사용할 수 있습니다.

Rust에서 모듈 시스템이 이렇게 작동하도록 선택한 이유는 내부 구현 세부사항을 숨기는 것이 기본적으로 설정되도록 하려는 것입니다. 이렇게 하면 어떤 부분의 내부 코드를 변경해도 외부 코드가 손상되지 않는지 분명히 알 수 있습니다. 그러나 하위 모듈 코드의 내부 부분을 상위 조상 모듈에 노출하려면, 항목을 공용(public)으로 만들어주는 `pub` 키워드를 사용해야 합니다.