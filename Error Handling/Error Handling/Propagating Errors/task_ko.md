### 오류 전파하기

실패할 가능성이 있는 함수를 구현할 때, 해당 함수 내부에서 오류를 처리하는 대신, 오류를 호출 코드로 반환하여 호출 코드가 이를 처리할 수 있게 할 수 있습니다. 이를 _오류 전파_라고 하며, 호출 코드가 오류를 처리하는 방식에 대해 더 많은 정보나 로직을 가지고 있을 가능성이 있으므로 더 많은 제어권을 부여합니다.

예를 들어, 아래 코드 조각은 파일에서 사용자 이름을 읽는 함수를 보여줍니다. 파일이 존재하지 않거나 읽을 수 없는 경우, 이 함수는 해당 오류를 이 함수를 호출한 코드로 반환합니다.

```rust
    use std::io;
    use std::io::Read;
    use std::fs::File;

    fn read_username_from_file() -> Result<String, io::Error> {
        let f = File::open("hello.txt");

        let mut f = match f {
            Ok(file) => file,
            Err(e) => return Err(e),
        };

        let mut s = String::new();

        match f.read_to_string(&mut s) {
            Ok(_) => Ok(s),
            Err(e) => Err(e),
        }
    }
```

##### `match`를 사용하여 호출 코드로 오류를 반환하는 함수

이 함수는 훨씬 더 간결하게 작성할 수 있지만, 오류 처리를 탐구하기 위해 처음에는 대부분의 동작을 수동으로 작성할 것입니다. 마지막에는 더 간단한 방법을 보여드리겠습니다. 우선 함수의 반환 타입을 확인해봅시다: `Result<String, io::Error>`. 이는 함수가 `Result<T, E>` 타입의 값을 반환한다는 것을 뜻하며, 여기서 제네릭 매개변수 `T`는 구체적인 타입 `String`으로 채워졌고, 제네릭 타입 `E`는 구체적인 타입 `io::Error`로 채워졌습니다. 만약 이 함수가 문제 없이 성공하면, 이 함수를 호출한 코드는 파일에서 읽은 사용자 이름이 담긴 `String` 값이 포함된 `Ok` 값을 받게 됩니다. 만약 이 함수가 문제를 만나 실패한다면, 호출한 코드는 어떤 문제가 있었는지에 대한 추가 정보를 담은 `io::Error` 인스턴스가 포함된 `Err` 값을 받게 됩니다. 우리는 이 함수의 반환 타입으로 `io::Error`를 선택했는데, 그 이유는 함수 본문에서 실패할 가능성이 있는 두 가지 작업 (`File::open` 함수와 `read_to_string` 메서드) 모두 `io::Error` 타입의 오류 값을 반환하기 때문입니다.

함수의 본문은 `File::open` 함수를 호출하는 것으로 시작됩니다. 그런 다음 이전 섹션 "반환될 수 있는 `Result` 변형을 처리하기 위해 `match` 표현식 사용하기"에 나왔던 `match`와 유사한 방식으로 `Result` 값을 처리합니다. 단, `Err` 경우에 `panic!`을 호출하는 대신 이 함수에서 일찍 반환하여 `File::open` 오류 값을 호출 코드로 전달합니다. 만약 `File::open`이 성공하면, 파일 핸들을 변수 `f`에 저장하고 계속 진행합니다.

그런 다음 변수 `s`에 새로운 `String`을 생성하고, 변수 `f`에 저장된 파일 핸들에서 `read_to_string` 메서드를 호출하여 파일의 내용을 `s`에 읽습니다. `read_to_string` 메서드 역시 실패할 가능성이 있기 때문에 `Result`를 반환합니다. 따라서 해당 `Result`를 처리하기 위해 또 다른 `match`가 필요합니다. 만약 `read_to_string`이 성공하면, 이 함수는 성공했으며 파일에서 읽어온 사용자 이름이 `Ok`로 감싸져 반환됩니다. 만약 `read_to_string`이 실패하면, `File::open`의 반환값을 처리했던 `match`에서 했던 것과 동일하게 오류 값을 반환합니다. 하지만 명시적으로 `return`을 작성할 필요는 없습니다. 왜냐하면 이 표현식이 함수의 마지막 표현식이기 때문입니다.

이 코드를 호출한 코드는 `String`이 담긴 `Ok` 값을 얻든지 `io::Error`가 담긴 `Err` 값을 얻든지 이에 따라 처리할 것입니다. 호출한 코드가 이러한 값을 어떻게 처리할지는 우리는 알 수 없습니다. 만약 호출 코드가 `Err` 값을 얻게 되면, `panic!`을 호출하여 프로그램을 중단하거나, 기본 사용자 이름을 사용할 수도 있으며, 파일이 아닌 다른 곳에서 사용자 이름을 조회할 수도 있습니다. 우리는 호출 코드가 실제로 무엇을 하려는지에 대한 충분한 정보를 가지고 있지 않으므로, 적절히 처리할 수 있도록 모든 성공 정보나 오류 정보를 상위로 전파합니다.

오류를 전파하는 이러한 패턴은 Rust에서 매우 일반적이어서, Rust는 이를 더 쉽게 만들기 위해 물음표 연산자 `?`를 제공합니다.