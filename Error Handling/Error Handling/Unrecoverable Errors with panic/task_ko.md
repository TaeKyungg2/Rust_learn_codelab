## 패닉으로 처리할 수 없는 오류

때때로 코드에서 문제가 발생할 수 있으며 이를 해결할 방법이 없을 때가 있습니다. 이런 경우, Rust는 `panic!` 매크로를 제공합니다. `panic!` 매크로가 실행되면 프로그램은 실패 메시지를 출력하고, 스택을 되돌아가며 정리한 다음 종료합니다. 이는 보통 어떤 종류의 버그가 감지되었을 때, 오류를 어떻게 처리해야 할지 프로그래머가 명확히 알지 못할 경우에 발생합니다.

> ### 패닉 발생 시 스택 되감기 또는 바로 종료
>
> 기본적으로, 패닉이 발생하면 프로그램은 _스택 되감기(unwinding)_를 시작합니다. 이것은 Rust가 스택을 거슬러 올라가면서 만나는 각 함수로부터 데이터를 정리하는 것을 의미합니다. 하지만 이런 되감기와 정리는 작업량이 많습니다. 대안으로는 바로 _종료(aborting)_를 선택할 수 있는데, 이는 정리 없이 프로그램을 즉시 종료합니다. 이 경우 프로그램이 사용하던 메모리는 운영 체제가 정리해야 합니다. 만약 프로젝트에서 결과적으로 생성되는 바이너리 크기를 최소화해야 한다면, _Cargo.toml_ 파일의 적절한 `[profile]` 섹션에 `panic = 'abort'`를 추가하여 스택 되감기 대신 종료하도록 설정할 수 있습니다. 예를 들어, 릴리스 모드에서 패닉 시 종료하고 싶다면 다음과 같이 추가합니다:
>
>     [profile.release]
>     panic = 'abort'

간단한 프로그램에서 `panic!`을 호출해 봅시다:

```rust
    fn main() {
        panic!("crash and burn");
    }
```

프로그램을 실행하면 다음과 같은 출력이 나타납니다:

```text
  Compiling test_rust_project v0.1.0
      Finished dev [unoptimized + debuginfo] target(s) in 0.42s
       Running `target/debug/test_rust_project`
  thread 'main' panicked at 'crash and burn', src/main.rs:2:5
```

`panic!` 호출은 마지막 두 줄에 나타나는 오류 메시지를 유발합니다. 첫 번째 줄은 패닉 메시지와 패닉이 발생한 소스 코드 위치를 보여줍니다: _src/main.rs:2:5_는 _src/main.rs_ 파일의 두 번째 줄, 다섯 번째 문자에서 패닉이 발생했음을 나타냅니다.

이 경우 표시된 줄은 우리의 코드 일부이며, 해당 줄로 가면 `panic!` 매크로 호출을 볼 수 있습니다. 다른 경우에는 `panic!` 호출이 우리가 호출한 다른 코드 안에 있을 수 있으며, 오류 메시지가 보고한 파일 이름과 줄 번호는 `panic!` 매크로가 호출된 다른 사람의 코드일 수 있습니다. 이때 `panic!` 호출이 어디에서 왔는지 확인하려면 함수들의 호출 기록인 역추적(backtrace)을 사용할 수 있습니다. 역추적이 무엇인지에 대해서는 이후에 자세히 논의하겠습니다.