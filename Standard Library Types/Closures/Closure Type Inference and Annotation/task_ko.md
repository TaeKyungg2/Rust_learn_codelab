### 클로저 타입 추론과 명시

함수와 클로저 사이에는 더 많은 차이점이 있습니다. 클로저는 일반적으로 `fn` 함수처럼 매개변수나 반환값의 타입을 명시할 필요가 없습니다. 함수에서 타입 명시는 필수인데, 이는 함수가 사용자에게 노출되는 명시적인 인터페이스의 일부이기 때문입니다. 이 인터페이스를 엄격하게 정의하는 것은 함수가 사용하는 값과 반환하는 값의 타입에 모두가 동의하도록 보장하기 위해 중요합니다. 하지만 클로저는 이런 방식으로 노출되는 인터페이스에서 사용되지 않습니다. 클로저는 변수에 저장되며 이름을 붙이거나 사용자가 라이브러리에서 볼 수 있도록 노출하지 않고 사용됩니다.

클로저는 일반적으로 짧고 임의의 시나리오보다는 좁은 문맥 내에서만 관련이 있습니다. 이러한 제한된 문맥 내에서는 컴파일러가 대부분의 변수 타입을 추론하는 것처럼 매개변수 타입과 반환 타입을 추론할 수 있습니다(컴파일러가 클로저의 타입 명시를 요구하는 드문 경우도 있습니다).

변수와 마찬가지로, 명확성과 명시성을 높이고 싶다면 더 많은 구체성을 필요로 하는 대가로 타입 명시를 추가할 수 있습니다. 클로저에 타입을 명시하는 방법은 아래에 나와 있는 정의와 같습니다:

```rust
    let expensive_closure = |num: u32| -> u32 {
        println!("천천히 계산 중...");
        thread::sleep(Duration::from_secs(2));
        num
    };
```

##### 클로저에 매개변수와 반환값 타입에 대한 선택적 타입 명시 추가 예시

타입 명시를 추가하면, 클로저의 문법은 함수 문법과 더 비슷해 보입니다. 아래는 매개변수에 1을 더하는 함수와 동일한 동작을 가진 클로저의 정의를 세로로 나란히 비교한 코드입니다. 관련된 부분을 정렬하기 위해 일부 간격을 추가했습니다. 이는 파이프와 선택적인 문법 사용 여부를 제외하고 클로저 문법이 함수 문법과 얼마나 비슷한지를 보여줍니다:

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

첫 번째 줄은 함수 정의를 나타내며, 두 번째 줄은 완전히 명시된 클로저 정의를 나타냅니다. 세 번째 줄은 클로저 정의에서 타입 명시를 제거한 것이고, 네 번째 줄은 클로저 본문에 표현식이 하나만 있는 경우 선택적으로 제거할 수 있는 중괄호를 생략한 것입니다. 이 모든 것은 호출 시 동일한 동작을 수행하는 유효한 정의들입니다. `add_one_v3`와 `add_one_v4`의 타입 추론이 사용된 호출로부터 이루어지기 때문에 컴파일 가능하게 하려면 클로저를 호출해야 합니다.

클로저 정의는 매개변수별로 하나의 고정된 타입과 반환값 타입을 추론합니다. 예를 들어, 아래는 매개변수로 받은 값을 그대로 반환하는 짧은 클로저 정의를 보여줍니다. 이 클로저는 예제의 목적 외에는 크게 유용하지 않습니다. 정의에 타입 명시를 추가하지 않았다는 점을 주의하세요. 이 클로저를 두 번 호출하면서 첫 번째는 `String`을, 두 번째는 `u32`를 인수로 전달하려고 하면 오류가 발생합니다.

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

##### 타입이 추론된 클로저를 서로 다른 타입으로 호출하려는 시도 예시

컴파일러는 아래와 같은 오류를 제공합니다:

```console
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- 도움말: 변환 메서드 사용해보세요: `.to_string()`
  |                             |
  |                             예상된 타입: `String`, 발견된 값: 정수

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
```

처음으로 `example_closure`를 `String` 값으로 호출하면, 컴파일러는 `x`와 클로저 반환값의 타입을 `String`으로 추론합니다. 그런 다음 `example_closure`에 이 타입이 고정되며, 동일한 클로저를 다른 타입으로 사용하려고 하면 타입 오류가 발생합니다.