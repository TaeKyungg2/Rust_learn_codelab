### 다른 반복자를 생성하는 메서드

`Iterator` 트레이트에 정의된 다른 메서드들, 즉 _반복자 어댑터_로 알려진 메서드들은 기존 반복자를 다른 종류의 반복자로 변환할 수 있도록 해줍니다. 여러 번의 반복자 어댑터 호출을 체인으로 연결하여 가독성 높은 방식으로 복잡한 작업을 수행할 수 있습니다. 하지만 모든 반복자가 게으르게 동작하므로, 반복자 어댑터 호출 결과를 얻으려면 반드시 소모 어댑터 메서드 중 하나를 호출해야 합니다.

다음 코드 스니펫은 `map`이라는 반복자 어댑터 메서드를 호출하는 예제를 보여줍니다. 이 메서드는 반복자의 각 항목에 대해 호출할 클로저를 받아 새로운 반복자를 생성합니다. 여기 사용된 클로저는 벡터의 각 항목에 1을 더한 값을 포함하는 새로운 반복자를 생성합니다. 그러나, 이 코드는 경고를 발생시킵니다:

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
```

##### 새로운 반복자를 생성하기 위해 map 반복자 어댑터 호출

우리가 받는 경고는 다음과 같습니다:

```text
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
```

이 마지막 예제의 코드는 아무 작업도 하지 않습니다. 우리가 지정한 클로저는 호출되지 않습니다. 경고는 그 이유를 알려줍니다: 반복자 어댑터는 게으르게 동작하며, 반복자를 여기서 소비해야 합니다.

이를 해결하고 반복자를 소비하려면, Rust 책 **[12장](https://doc.rust-lang.org/stable/book/ch12-01-accepting-command-line-arguments.html)**에서 `env::args`와 함께 다루었던 `collect` 메서드를 사용해야 합니다. 이 메서드는 반복자를 소비하고 그 결과 값을 컬렉션 데이터 타입에 수집합니다.

다음 예제에서, 우리는 `map` 호출로 반환된 반복자를 순회한 결과를 벡터에 수집합니다. 이 벡터는 원래 벡터의 각 항목에 1을 더한 값을 포함하게 됩니다.

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
```

##### map 메서드를 호출하여 새로운 반복자를 생성한 다음 collect 메서드를 호출하여 이 새로운 반복자를 소비하고 벡터 생성

`map`은 클로저를 받기 때문에 각 항목에 대해 원하는 작업을 지정할 수 있습니다. 이는 클로저를 사용해 동작을 사용자 정의하면서도 `Iterator` 트레이트가 제공하는 반복 작업을 재사용하는 좋은 예입니다.