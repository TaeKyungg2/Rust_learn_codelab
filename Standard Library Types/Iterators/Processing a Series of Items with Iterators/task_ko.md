## 반복자를 사용하여 일련의 항목 처리하기

반복자 패턴(iterator pattern)은 일련의 항목에 대해 순차적으로 작업을 수행할 수 있게 해줍니다. 반복자는 각 항목을 순회(iterate)하고, 시퀀스가 끝났는지 판단하는 논리를 담당합니다. 반복자를 사용하면 이러한 논리를 직접 구현할 필요가 없습니다.

Rust에서 반복자는 _지연 평가(lazy)_됩니다. 즉, 반복자를 소비하여 활용하는 메서드를 호출하기 전까지는 아무런 효과도 발생하지 않습니다. 아래 코드 스니펫의 예는 벡터 `v1`에 있는 항목을 반복할 수 있는 반복자를 `Vec<T>`에 정의된 `iter` 메서드를 호출하여 생성합니다. 하지만 이 코드는 자체적으로는 유용한 작업을 수행하지 않습니다.

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
```

##### 반복자 생성하기

일단 반복자를 생성하면 다양한 방식으로 사용할 수 있습니다. "공통 프로그래밍 개념/만약" 섹션에서 `for` 루프와 함께 반복자를 사용하여 각 항목에 대해 코드를 실행했지만, 그 당시에는 `iter` 호출의 작동 방식을 자세히 다루지는 않았습니다.

다음 코드 스니펫의 예는 반복자 생성과 `for` 루프에서 반복자를 사용하는 단계를 분리합니다. 반복자는 `v1_iter` 변수에 저장되며, 이때는 아직 반복 작업이 수행되지 않습니다. `for` 루프가 `v1_iter`에 저장된 반복자를 사용하여 호출되면, 반복자의 각 요소가 루프의 한 번의 반복에서 사용되며, 각 값을 출력하게 됩니다.

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
```

##### for 루프에서 반복자 사용하기

표준 라이브러리에서 반복자를 제공하지 않는 언어에서는 보통 인덱스 0에서 시작하는 변수를 선언하고, 이 변수를 사용해 벡터에서 값을 가져온 후, 루프를 실행하면서 변수 값을 증가시키고, 벡터에 있는 항목 수에 도달할 때까지 이 작업을 반복할 것입니다.

반복자는 이러한 논리를 모두 처리하여 반복적인 코드를 줄이고, 사용 중 실수를 범할 가능성을 줄여줍니다. 반복자를 사용하면 벡터와 같이 인덱싱할 수 있는 데이터 구조만이 아니라 여러 종류의 시퀀스에서 동일한 논리를 유연하게 사용할 수 있습니다. 이제 반복자가 이러한 작업을 어떻게 수행하는지 살펴보겠습니다.