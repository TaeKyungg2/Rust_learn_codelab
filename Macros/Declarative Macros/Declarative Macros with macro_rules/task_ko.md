### `macro_rules!`를 사용한 선언적 매크로와 일반 메타프로그래밍

Rust에서 가장 널리 사용되는 매크로의 형태는 _선언적 매크로_입니다. 이러한 매크로는 때때로 "예제로 본 매크로", "`macro_rules!` 매크로" 또는 단순히 "매크로"라고도 불립니다. 기본적으로 선언적 매크로는 Rust의 `match` 표현과 유사한 것을 작성할 수 있게 해줍니다. 6장에서 논의된 바와 같이, `match` 표현식은 표현식을 받아 그 표현식의 결과값을 패턴과 비교한 뒤, 일치하는 패턴에 연결된 코드를 실행하는 제어 구조입니다. 매크로 또한 특정 코드와 연결된 패턴과 값을 비교합니다. 이때 값은 매크로에 전달된 Rust 소스 코드이며, 패턴은 해당 소스 코드의 구조와 비교됩니다. 그리고 패턴이 일치하면, 연결된 코드가 매크로에 전달된 코드를 대체하게 됩니다. 이는 모두 컴파일 시점에 발생합니다.

매크로를 정의하려면 `macro_rules!` 구조를 사용합니다. `macro_rules!`의 사용 방법을 알아보기 위해 `vec!` 매크로가 정의된 방식을 살펴보겠습니다. 8장에서 `vec!` 매크로를 사용해 특정 값을 포함한 새로운 벡터를 생성할 수 있는 방법을 다룬 바 있습니다. 예를 들어, 아래의 매크로는 세 개의 정수를 포함하는 새로운 벡터를 생성합니다.

```rust
    let v: Vec<u32> = vec![1, 2, 3];
```

또한 `vec!` 매크로를 사용해 두 개의 정수로 이루어진 벡터나 다섯 개의 문자열 슬라이스로 이루어진 벡터를 생성할 수도 있습니다. 함수로는 동일한 작업을 수행할 수 없습니다. 그 이유는 미리 값의 개수나 타입을 알 수 없기 때문입니다.

다음 코드 스니펫은 `vec!` 매크로의 약간 단순화된 정의를 보여줍니다.

```rust
    #[macro_export]
    macro_rules! vec {
        ( $( $x:expr ),* ) => {
            {
                let mut temp_vec = Vec::new();
                $(
                    temp_vec.push($x);
                )*
                temp_vec
            }
        };
    }
```

##### vec! 매크로 정의의 단순화된 버전

> 참고: 표준 라이브러리에 있는 `vec!` 매크로의 실제 정의는 메모리를 사전에 적절히 할당하는 코드를 포함합니다. 이 코드는 예제를 단순화하기 위해 여기서는 포함하지 않았습니다.

`#[macro_export]` 애노테이션은 매크로가 정의된 크레이트가 스코프에 들어올 때마다 이 매크로를 사용할 수 있도록 해야 한다는 것을 나타냅니다. 이 애노테이션이 없으면, 매크로를 스코프에 가져올 수 없습니다.

이후 `macro_rules!` 키워드와 정의 중인 매크로의 이름을 작성하며, 이름 뒤에는 느낌표 없이 작성합니다. 이 경우 매크로 이름은 `vec`이며, 중괄호를 사용해 매크로 정의 본체를 둘러쌉니다.

`vec!` 본체의 구조는 `match` 표현식의 구조와 유사합니다. 여기에는 `( $( $x:expr ),* )` 패턴과 이를 따른 `=>`, 그리고 이 패턴과 연결된 코드 블록이 있습니다. 패턴이 일치하면 연결된 코드 블록이 생성됩니다. 이 매크로에서는 유효한 패턴이 하나만 존재하므로, 다른 패턴이 들어오면 에러가 발생합니다. 보다 복잡한 매크로는 여러 개의 패턴을 가질 수 있습니다.

매크로 정의에서의 유효한 패턴 문법은 Chapter 18에서 다룬 일반 패턴 문법과 다릅니다. 매크로 패턴은 값이 아닌 Rust 코드 구조와 매칭되기 때문입니다. 위 코드 스니펫에 나타난 패턴의 구성 요소를 살펴보겠습니다. 매크로 패턴 문법의 전체 내용은 [참조 자료](https://doc.rust-lang.org/1.30.0/book/first-edition/macros.html)를 확인하세요.

먼저, 괄호로 패턴 전체를 감쌉니다. 그 뒤 `$` 기호가 나타나며, 이는 값이 패턴과 매칭되어 교체 코드에서 활용될 수 있도록 해당 값을 캡처하는 역할을 합니다. `$()` 안에는 `$x:expr`이 있으며, 이는 Rust의 표현식과 매칭하며 이 표현식에 `$x`라는 이름을 부여합니다.

`$()` 뒤에 오는 쉼표는 매칭된 패턴 뒤에 쉼표가 선택적으로 등장할 수 있음을 나타냅니다. `*`는 패턴이 앞의 요소와 다수 번 매칭될 수 있음을 나타냅니다.

`vec![1, 2, 3];`처럼 매크로를 호출하면 `$x` 패턴이 세 번 매칭되며, 각각 1, 2, 3이라는 표현식과 매칭됩니다.

그 다음, 코드 본체의 패턴을 살펴보겠습니다. `temp_vec.push()`는 `$()*` 내부에 있으므로, 이 코드는 `$()` 패턴이 몇 번 매칭되는지에 따라 반복적으로 생성됩니다. 그리고 `$x`는 매칭된 각각의 표현식으로 대체됩니다. `vec![1, 2, 3];`를 호출했을 때, 매크로 호출을 대체하는 생성된 코드는 다음과 같습니다.

```rust
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
```

우리는 임의의 타입과 개수를 가진 인수를 받아 지정된 요소를 포함하는 벡터를 생성하기 위한 코드를 생성할 수 있는 매크로를 정의했습니다.

`macro_rules!`에는 다소 이상한 에지 케이스가 존재합니다. 앞으로 Rust에는 이러한 에지 케이스를 수정하고 유사한 방법으로 동작하는 두 번째 형태의 선언적 매크로가 도입될 예정입니다. 이후 `macro_rules!`는 사실상 더 이상 사용되지 않게 될 것입니다. 대부분의 Rust 프로그래머는 매크로를 _작성_하기보다는 _사용_할 일이 더 많다는 점과 이러한 향후 변경점을 고려하여, 여기서 `macro_rules!`에 대해 더 이상의 논의는 하지 않겠습니다. 매크로 작성 방법에 대한 자세한 내용은 온라인 문서나 [“The Little Book of Rust Macros”](https://danielkeep.github.io/tlborm/book/index.html) 같은 리소스를 참조하세요.