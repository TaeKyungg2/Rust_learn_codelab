## 변수와 데이터의 상호작용 방식: 이동(Move)

러스트에서는 여러 변수가 동일한 데이터를 다양한 방식으로 상호작용할 수 있습니다. 아래 코드 스니펫에서 정수를 사용하는 예제를 살펴보겠습니다.

```rust
let x = 5;
let y = x;
```

##### 변수 x의 정수 값을 y에 할당

이 코드가 무엇을 하는지 쉽게 추측할 수 있습니다: "`x`에 값 `5`를 할당하고, 그 다음 `x`의 값을 복사하여 `y`에 할당한다." 이제 `x`와 `y` 두 변수가 존재하며, 둘 다 `5`와 같습니다. 이것이 사실 어떻게 동작하는지입니다. 왜냐하면 정수는 크기가 고정되고 단순한 값이기 때문입니다. 이 두 개의 `5` 값은 스택(stack)에 저장됩니다.

이제 `String` 버전을 살펴보겠습니다:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

이 코드도 이전 코드와 매우 유사해 보이므로, 이것이 동일한 방식으로 동작할 것이라고 가정할 수 있습니다. 즉, 두 번째 줄에서 `s1`의 값을 복사하여 `s2`에 할당한다고 생각할 수 있습니다. 그러나 실제로는 그렇지 않습니다.

`String`이 내부적으로 어떻게 동작하는지 살펴보세요. 아래 그림 1은 `String`의 구성 요소를 보여줍니다. `String`은 세 부분으로 이루어져 있습니다: 문자열 내용이 저장된 메모리의 포인터, 길이, 그리고 할당 용량입니다. 이 데이터들은 왼쪽에서 볼 수 있듯 스택에 저장됩니다. 오른쪽에는 힙(heap) 메모리에 문자열 내용이 저장되어 있습니다.

<img alt="메모리 내 String 구조" src="https://doc.rust-lang.org/stable/book/img/trpl04-01.svg" class="center" style="width: 50%;">

##### 그림 1: 문자열 값 "hello"가 s1에 바인딩된 상태의 메모리 표현

`String`의 길이는 현재 문자열이 사용하고 있는 메모리의 크기를 바이트 단위로 나타냅니다. 할당 용량은 할당자(allocator)로부터 받은 총 메모리의 크기를 바이트 단위로 나타냅니다. 길이와 용량의 차이는 중요하지만, 이 문맥에서는 무시해도 괜찮습니다.

`s1`을 `s2`에 할당할 때, `String` 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이, 용량이 복사됩니다. 하지만 포인터가 참조하는 힙의 데이터는 복사되지 않습니다. 다시 말해, 메모리 상의 데이터 표현은 그림 2와 같습니다.

<img alt="s1과 s2가 동일한 값을 참조" src="https://doc.rust-lang.org/stable/book/img/trpl04-02.svg" class="center" style="width: 50%;">

##### 그림 2: s1의 포인터, 길이, 용량을 복사한 s2의 메모리 표현

이 상황은 그림 3처럼 나타나지 않습니다. 그림 3은 러스트가 힙 데이터를 복사했을 경우 메모리가 어떻게 보일지를 보여줍니다. 만약 러스트가 힙 데이터를 복사했다면, `s2 = s1` 연산은 힙에 커다란 데이터가 있는 경우 실행 시간 성능 면에서 매우 비용이 비쌌을 것입니다.

<img alt="s1과 s2 두 곳에 복사된 데이터" src="https://doc.rust-lang.org/stable/book/img/trpl04-03.svg" class="center" style="width: 50%;">

##### 그림 3: 러스트가 힙 데이터를 복사했다면 s2 = s1이 실행된 후 메모리 상태

앞서 언급했듯 변수가 스코프 밖으로 벗어나면, 러스트는 자동으로 `drop` 함수를 호출하여 해당 변수가 사용하던 힙 메모리를 정리합니다. 하지만 그림 2에서는 두 개의 데이터 포인터가 동일한 위치를 참조하고 있습니다. 이는 문제를 야기합니다: `s2`와 `s1`이 스코프 밖으로 벗어날 때, 두 변수 모두 동일한 메모리를 해제하려 시도할 것입니다. 이것은 _이중 해제(double free)_ 오류라고 불리며, 이전에 언급한 메모리 안전성 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상이 발생할 수 있으며, 이는 곧 보안 취약점으로 이어질 수 있습니다.

메모리 안전성을 보장하기 위해, 러스트는 이 상황에서 한 가지 추가적인 조치를 취합니다. 할당된 메모리를 복사하려고 하는 대신, 러스트는 `s1`을 더 이상 유효하지 않다고 간주합니다. 따라서 `s1`이 스코프 밖으로 벗어날 때 러스트는 아무것도 해제하지 않습니다. `s2`를 생성한 후 `s1`을 사용하려 시도하면 어떻게 되는지 확인하세요. 동작하지 않을 것입니다:

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

러스트는 무효화된 참조를 사용하지 못하도록 방지하므로 다음과 같은 오류가 발생합니다:

```text
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
```

다른 언어에서 _얕은 복사(shallow copy)_와 _깊은 복사(deep copy)_라는 용어를 들어본 적이 있다면, 포인터, 길이, 용량을 복사하되 데이터를 복사하지 않는 개념이 얕은 복사와 비슷하다는 점을 느낄 것입니다. 하지만 러스트는 첫 번째 변수를 무효화하기 때문에, 얕은 복사가 아닌 _이동(move)_이라 불립니다. 이 예제에서는 `s1`이 `s2`로 _이동했다(moved)_고 표현합니다. 실제로 일어나는 일은 그림 4와 같습니다.

<img alt="s1이 s2로 이동" src="https://doc.rust-lang.org/stable/book/img/trpl04-04.svg" class="center" style="width: 50%;">

##### 그림 4: s1이 무효화된 후 메모리 표현

이렇게 하면 문제가 해결됩니다. 이제 `s2`만 유효하므로, `s2`가 스코프 밖으로 벗어날 때 혼자 메모리를 해제하며 일이 끝납니다.

또한, 여기에는 특정한 설계 선택이 암시되어 있습니다: 러스트는 절대로 데이터를 "깊게(deep)" 복사하지 않습니다. 따라서 모든 _자동_ 복사는 실행 시간 성능 면에서 비용이 적게 들 것으로 간주할 수 있습니다.