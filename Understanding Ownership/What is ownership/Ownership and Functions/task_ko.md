## 소유권과 함수

값을 함수에 전달하는 의미는 변수에 값을 할당하는 것과 유사합니다. 변수를 함수로 전달하면, 할당 시처럼 이동되거나 복사됩니다. 아래 예제는 주석과 함께 변수가 스코프 안팎으로 이동하는 위치를 보여줍니다.

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옴

    takes_ownership(s);             // s의 값이 함수로 이동...
    // ... 따라서 여기에서는 더 이상 유효하지 않음

    let x = 5;                      // x가 스코프 안으로 들어옴

    makes_copy(x);                  // x가 함수로 이동할 것이지만,
    // i32는 Copy 특성을 가지므로 여전히
    // 이후에도 x를 사용할 수 있음

} // 여기에서 x가 스코프 밖으로 나가고, 그 후 s도 스코프 밖으로 나감. 하지만 s의 값은 이동되었으므로
// 특별한 일이 발생하지 않음.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옴
    println!("{}", some_string);
} // 여기에서 some_string은 스코프 밖으로 나가며 `drop`이 호출됨. 할당된 메모리가 해제됨.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어옴
    println!("{}", some_integer);
} // 여기에서 some_integer은 스코프 밖으로 나감. 특별한 일이 발생하지 않음.
```

##### 소유권과 스코프를 주석으로 표시한 함수

`takes_ownership` 함수를 호출한 이후에 `s`를 사용하려고 한다면, Rust는 컴파일 타임 에러를 발생시킬 것입니다. 이러한 정적 검사들은 실수를 방지하도록 보호해줍니다. `main` 함수에 `s`와 `x`를 사용하는 코드를 추가하여 어느 위치에서 사용할 수 있고, 소유권 규칙에 의해 사용할 수 없는지 확인해 보세요.