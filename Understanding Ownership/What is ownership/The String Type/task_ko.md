## 문자열(String) 타입

소유권의 규칙을 설명하기 위해, 우리는 ["데이터 타입"](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#data-types) 섹션에서 다룬 것보다 더 복잡한 데이터 타입이 필요합니다. 이전에 다뤘던 타입들은 모두 스택(stack)에 저장되고 해당 스코프가 끝나면 스택에서 제거됩니다. 그러나 우리는 힙(heap)에 저장된 데이터를 살펴보고 Rust가 데이터를 정리해야 할 시점을 어떻게 아는지 탐구해볼 것입니다.

여기서 우리는 예제로 `String`을 사용할 것이며, `String`의 소유권과 관련된 부분에 집중할 것입니다. 이러한 측면은 표준 라이브러리가 제공하든, 여러분이 생성하든 다른 복잡한 데이터 타입에도 적용됩니다. `String`에 대한 보다 심층적인 논의는 "일반 컬렉션(Common Collections)" 장에서 다룰 것입니다.

이미 문자열 리터럴(string literal)을 본 적이 있을 겁니다. 문자열 리터럴은 프로그램에 하드코딩된 문자열 값입니다. 문자열 리터럴은 편리하지만, 텍스트를 사용하고자 하는 모든 상황에서는 적합하지 않을 수 있습니다. 그 이유 중 하나는 문자열 리터럴이 불변(immutable)하다는 점입니다. 또 다른 이유로, 코드를 작성할 때 각 문자열 값을 모두 알 수 있는 것은 아닙니다. 예를 들어, 사용자 입력을 받아 저장하고 싶다면 어떻게 해야 할까요? 이러한 상황을 위해 Rust에는 또 다른 문자열 타입인 `String`이 존재합니다. 이 타입은 힙에 할당되며, 컴파일 시점에 알 수 없는 양의 텍스트를 저장할 수 있습니다. `from` 함수를 사용하여 문자열 리터럴로부터 `String`을 생성할 수 있습니다. 예를 들어:

```rust
let s = String::from("hello");
```

두 개의 콜론(`::`)은 특정 `from` 함수가 `String` 타입 아래 네임스페이스로 존재하도록 해주는 연산자입니다. 이 문법에 대해서는 5장의 ["메서드 문법"](https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html#method-syntax) 섹션과 7장의 ["모듈 트리에서 항목을 참조하기 위한 경로"](https://doc.rust-lang.org/stable/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) 섹션에서 더 자세히 논의할 것입니다.

이러한 종류의 문자열은 _변경 가능_합니다:

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str()은 문자열에 리터럴을 추가합니다.

println!("{}", s); // 이는 `hello, world!`를 출력합니다.
```

그렇다면 여기서 차이가 무엇일까요? 왜 `String`은 변경 가능하지만, 리터럴은 불가능할까요? 그 차이는 이 두 타입이 메모리를 다루는 방식에 있습니다.

### 메모리와 할당

문자열 리터럴의 경우, 컴파일 시점에 내용이 알려져 있으므로 텍스트가 최종 실행 파일에 하드코딩됩니다. 문자열 리터럴이 빠르고 효율적인 이유는 바로 이 때문입니다. 그러나 이러한 특성은 문자열 리터럴의 불변성에서 비롯됩니다. 불행히도 컴파일 시점에 크기를 알 수 없거나 프로그램 실행 중 크기가 변경될 수 있는 텍스트에 대해 이러한 메모리를 실행 파일에 포함시킬 수는 없습니다.

`String` 타입의 경우, 변경 가능하고 성장 가능한 텍스트를 지원하려면 컴파일 시점에 알 수 없는 양의 메모리를 힙에 할당하여 내용을 저장해야 합니다. 이는 다음 사항을 의미합니다:

*   실행 중 메모리 할당자로부터 메모리를 요청해야 합니다.
*   `String`을 더 이상 사용하지 않을 때 이 메모리를 할당자에게 반환할 방법이 필요합니다.

첫 번째 작업은 우리가 수행합니다. `String::from`을 호출하면, 해당 구현은 필요한 메모리를 요청합니다. 이는 대부분의 프로그래밍 언어에서 보편적인 방식입니다.

하지만 두 번째 부분은 다릅니다. _가비지 컬렉터(GC)_가 있는 언어에서는 GC가 사용되지 않는 메모리를 추적하고 정리하므로, 우리는 이에 대해 신경 쓸 필요가 없습니다. GC가 없는 경우, 메모리가 더 이상 사용되지 않을 때를 식별하여 명시적으로 반환하는 코드를 작성하는 것은 우리의 몫입니다. 올바르게 처리하지 않으면 메모리를 낭비할 수 있습니다. 너무 일찍 반환하면 변수는 유효하지 않게 되고, 두 번 반환하면 버그가 됩니다. 정확히 하나의 `할당`과 하나의 `해제`를 쌍으로 맞춰야 합니다.

Rust는 다른 방식을 채택했습니다. 변수를 소유한 범위가 끝나면 메모리가 자동으로 반환됩니다. 이전 코드 스니펫에서 문자열 리터럴 대신 `String`을 사용하는 스코프 예시는 다음과 같습니다:

```rust
{
let s = String::from("hello"); // s는 이 시점부터 유효합니다.

// s를 사용하여 작업 수행
}                                  // 이 스코프는 이제 끝났으며 s는 더
// 이상 유효하지 않습니다.
```

이 경우 `String`이 필요로 하는 메모리를 할당자에게 반환할 자연스러운 시점이 있습니다: 바로 `s`가 스코프를 벗어날 때입니다. 변수가 스코프를 벗어나면, Rust는 우리를 대신해 특별한 함수를 호출합니다. 이 함수는 `drop`이라고 하며, 여기에서 `String` 작성자가 메모리를 반환하는 코드를 넣을 수 있습니다. Rust는 닫는 중괄호에서 자동으로 `drop`을 호출합니다.

> 참고: C++에서는 이러한 리소스 할당 해제 패턴을 _생성자에서 리소스 획득(Resource Acquisition Is Initialization, RAII)_이라고 부릅니다. Rust의 `drop` 함수는 RAII 패턴을 사용해본 경험이 있는 분들에게 익숙할 것입니다.

이 패턴은 Rust 코드 작성 방식에 상당한 영향을 미칩니다. 지금은 단순해 보일 수 있지만, 힙에 할당된 데이터를 여러 변수가 사용하고자 할 때 더 복잡한 상황에서 코드의 동작이 예상치 못할 수 있습니다. 이제 이러한 상황을 탐구해 봅시다.