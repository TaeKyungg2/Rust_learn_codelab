## 변수와 데이터의 상호작용 방법: Clone

`String`의 스택 데이터만이 아니라 힙 데이터도 깊은 복사를 하고 싶다면, `clone`이라는 일반적인 메서드를 사용할 수 있습니다. 메서드 문법에 대해서는 "Structs" 장에서 다룰 예정이지만, 메서드는 많은 프로그래밍 언어에서 흔히 사용되므로, 아마 이미 사용해보셨을 겁니다.

다음은 `clone` 메서드를 사용한 예제입니다:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

이 코드는 잘 작동하며, 힙 데이터가 복사되는 Figure 3에서 보여지는 동작을 명확히 제공합니다.

`clone` 호출을 보면, 어떤 임의의 코드가 실행되고 있으며, 그 코드가 비용이 많이 들 수 있다는 것을 알 수 있습니다. 이는 뭔가 다른 동작이 이루어지고 있음을 나타내는 시각적 표시입니다.

## 스택 전용 데이터: Copy

아직 설명하지 않은 또 다른 특징이 있습니다. 정수를 사용하는 다음 코드(일부는 "변수 x의 정수 값을 y에 할당하기" 코드 조각에서 보여졌던 것)는 올바르게 작동합니다:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

하지만 이 코드는 우리가 방금 배운 것과 모순되어 보입니다. `clone`을 호출하지 않았지만, `x`는 여전히 유효하고 `y`로 이동되지 않았습니다.

그 이유는 컴파일 타임에 크기가 정해져 있는 정수와 같은 타입들은 전적으로 스택에 저장되며, 실제 값의 복사가 빠르게 이루어지기 때문입니다. 따라서 변수를 `y`로 생성한 후에도 `x`를 유효하지 않게 만들 이유가 없습니다. 즉, 여기서는 깊은 복사와 얕은 복사 간의 차이가 없으므로, `clone`을 호출해도 기본 얕은 복사와 다를 바가 없으며, 생략할 수 있습니다.

Rust에서는 정수처럼 스택에 저장되는 타입에 대해 `Copy` 트레이트라는 특수한 주석을 사용할 수 있습니다(트레이트에 대해서는 10장에서 더 알아볼 것입니다). 타입이 `Copy` 트레이트를 구현하면, 이전 변수는 할당 후에도 여전히 사용할 수 있습니다. 만약 어떤 타입 또는 그 일부가 `Drop` 트레이트를 구현한 경우, Rust는 해당 타입에 `Copy` 트레이트를 추가하지 못하도록 합니다. 타입이 범위를 벗어날 때 특별한 작업이 필요하고 그 타입에 `Copy` 주석을 추가하면, 컴파일 타임 오류를 얻게 됩니다. 트레이트를 구현하기 위해 타입에 `Copy` 주석을 추가하는 방법은 [“파생 가능한 트레이트들”](https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html)을 참고하세요.

그렇다면 어떤 타입이 `Copy` 트레이트를 구현할까요? 특정 타입의 문서를 확인하면 확신할 수 있지만, 일반적으로 단순한 스칼라 값으로 구성된 그룹은 `Copy`를 구현할 수 있고, 메모리 할당이 필요하거나 자원의 일종인 것은 `Copy`를 구현할 수 없습니다. 다음은 `Copy` 트레이트를 구현하는 몇 가지 타입들입니다:

* 모든 정수 타입들, 예를 들어 `u32`.
* 값이 `true`와 `false`인 불리언 타입 `bool`.
* 모든 부동 소수점 타입들, 예를 들어 `f64`.
* 문자 타입 `char`.
* 구성 요소가 모두 `Copy`를 구현하는 경우의 튜플. 예를 들어 `(i32, i32)`는 `Copy`를 구현하지만 `(i32, String)`은 그렇지 않습니다.