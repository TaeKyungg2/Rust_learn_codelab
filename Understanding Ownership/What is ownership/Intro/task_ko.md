## 소유권 이해하기

소유권(Ownership)은 Rust의 가장 독특한 기능이며, 이를 통해 Rust는 가비지 컬렉터 없이도 메모리 안전성을 보장할 수 있습니다. 따라서 Rust에서 소유권이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 장에서는 소유권뿐만 아니라 관련된 여러 기능들, 즉 빌리기(Borrowing), 슬라이스(Slices), 그리고 Rust가 메모리에 데이터를 배치하는 방식에 대해 다룰 것입니다.

## 소유권이란?

Rust의 중심 기능은 _소유권_입니다. 이 기능은 간단하게 설명할 수 있지만, 언어 전반에 걸쳐 깊은 영향을 미칩니다.

모든 프로그램은 실행 중 컴퓨터 메모리를 사용하는 방식을 관리해야 합니다. 일부 언어는 프로그램이 실행 중일 때 더 이상 사용되지 않는 메모리를 지속적으로 찾는 가비지 컬렉션을 사용합니다. 반면 다른 언어는 프로그래머가 메모리를 명시적으로 할당하고 해제해야 합니다. Rust는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 컴파일 타임에 확인하는 규칙 세트를 가진 소유권 시스템을 통해 관리됩니다. 소유권 기능은 프로그램 실행 중 속도를 저하시키지 않습니다.

소유권은 많은 프로그래머들에게 새로운 개념이기 때문에 익숙해지기까지는 시간이 걸릴 수 있습니다. 좋은 소식은 Rust와 소유권 시스템 규칙에 더 익숙해질수록, 안전하고 효율적인 코드를 자연스럽게 작성할 수 있다는 점입니다. 꾸준히 연습하세요!

소유권을 이해하면 Rust를 독특하게 만드는 기능을 이해할 수 있는 탄탄한 기반을 가지게 됩니다. 이 장에서는 소유권을 배우기 위해, 문자열(Strings)이라는 매우 일반적인 데이터 구조에 초점을 맞춘 몇 가지 예제를 다룰 것입니다.

### 스택과 힙

많은 프로그래밍 언어에서 스택(Stack)과 힙(Heap)에 대해 자주 고민할 필요가 없습니다. 그러나 Rust와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지가 언어의 동작 방식과 특정 결정을 내려야 하는 이유에 더 큰 영향을 미칩니다. 이 장의 뒷부분에서 스택과 힙과 관련하여 소유권의 일부를 설명할 예정이므로, 이를 대비하여 간략히 설명해 보겠습니다.

스택과 힙은 모두 실행 시간 동안 코드가 사용할 수 있는 메모리의 일부이지만, 구조는 다릅니다. 스택은 데이터를 받는 순서대로 저장하고 반대로 제거합니다. 이를 _후입선출_(Last In, First Out)이라고 합니다. 접시를 쌓아 올리는 것을 상상해 보세요. 접시를 더 추가할 때는 쌓여 있는 더미의 맨 위에 올리고, 접시가 필요할 때는 맨 위에서 하나를 가져옵니다. 중간이나 아래에서 접시를 추가하거나 제거하는 것은 잘 작동하지 않을 것입니다! 데이터를 추가하는 것을 _스택에 푸시(Push)_라고 하고, 데이터를 제거하는 것을 _스택에서 팝(Pop)_이라고 합니다.

스택에 저장된 모든 데이터는 알려진 고정 크기를 가져야 합니다. 컴파일 타임에 크기가 알려지지 않았거나 크기가 변경될 수 있는 데이터는 대신 힙에 저장되어야 합니다. 힙은 더 정리가 덜 되어 있습니다. 힙에 데이터를 넣을 때 특정한 크기의 공간을 요청하며, 메모리 할당기는 힙에서 충분히 큰 빈 공간을 찾아 사용 중으로 표시한 다음, 해당 위치의 주소인 _포인터(Pointer)_를 반환합니다. 이 과정을 _힙에서의 할당_(Allocating on the Heap)이라고 하며, 간단히 _할당_(Allocating)이라고 줄이기도 합니다. 스택에 값을 푸시하는 것은 할당으로 간주되지 않습니다. 포인터는 고정된 크기를 가지므로 스택에 저장할 수 있지만, 실제 데이터를 원할 때는 포인터를 따라가야 합니다.

레스토랑에서 자리를 잡는 상황을 떠올려 보세요. 입장 시, 일행의 인원수를 말하면 직원이 모든 인원을 수용할 빈 테이블을 찾아 안내합니다. 만약 당신의 일행 중 한 명이 늦게 도착한다면, 그들은 당신이 어디에 앉아 있는지 물어서 찾아올 수 있습니다.

스택에 데이터를 푸시하는 것은 힙에서 공간을 할당하는 것보다 빠릅니다. 할당기가 새로운 데이터를 저장할 위치를 찾기 위해 검색할 필요가 없기 때문입니다. 해당 위치는 항상 스택의 맨 위에 있기 때문입니다. 비교적으로, 힙에 공간을 할당하는 것은 더 많은 작업이 필요합니다. 할당기가 데이터를 저장할 만큼 충분히 큰 공간을 찾고, 다음 할당을 준비하기 위해 부기 작업을 수행해야 하기 때문입니다.

힙의 데이터를 접근하는 것은 스택보다 느립니다. 포인터를 따라가야 하기 때문입니다. 현대 프로세서는 메모리를 덜 이동할수록 더 빠르게 동작합니다. 다시 비유를 들어보면, 한 레스토랑 서버가 여러 테이블의 주문을 받는다고 합시다. 한 테이블의 주문을 모두 받은 후 다른 테이블로 이동하는 것이 가장 효율적입니다. 테이블 A에서 주문을 받고, B에서 주문을 받고, 다시 A로 돌아가고, 또 다시 B로 돌아가는 식으로 주문을 받는 것은 훨씬 느린 과정일 것입니다. 마찬가지로, 프로세서는 스택처럼 데이터가 서로 가까운 경우, 힙처럼 데이터가 멀리 떨어져 있는 경우보다 작업을 더 잘 처리합니다. 또한 힙에서 대량의 공간을 할당하는 것 역시 시간이 걸릴 수 있습니다.

당신의 코드가 함수를 호출하면, 함수에 전달된 값들(히프의 데이터에 대한 포인터를 포함할 수 있음)과 함수의 지역 변수는 스택에 푸시됩니다. 함수가 종료되면, 해당 값들은 스택에서 팝됩니다.

힙에서 어떤 부분의 코드가 어떤 데이터를 사용하는지, 힙에서 중복 데이터를 최소화하는 방법, 그리고 힙에서 사용되지 않는 데이터를 정리하여 공간 부족을 방지하는 방법 등을 추적하는 것은 모두 소유권이 해결하는 문제입니다. 소유권을 이해하고 나면 스택과 힙에 대해 자주 고민하지 않아도 됩니다. 그러나 힙 데이터 관리를 위해 소유권이 존재한다는 것을 알면 소유권이 왜 특정 방식으로 작동하는지 설명하는 데 도움이 됩니다.

### 소유권 규칙

먼저, 소유권 규칙을 살펴보겠습니다. 이 규칙들을 염두에 두고 이를 설명하는 예제를 진행해 보세요:

*   Rust의 모든 값은 _소유자(Owner)_라고 불리는 변수를 가집니다.
*   한 번에 하나의 소유자만 있을 수 있습니다.
*   소유자가 스코프 밖으로 이동하면, 해당 값은 삭제됩니다.