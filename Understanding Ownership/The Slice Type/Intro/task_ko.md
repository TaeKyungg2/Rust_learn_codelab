## 슬라이스 타입

소유권을 가지지 않는 또 다른 데이터 타입은 _슬라이스(slice)_ 입니다. 슬라이스는 컬렉션 전체가 아닌 컬렉션 내의 연속적인 요소 시퀀스를 참조할 수 있게 해줍니다.

다음은 간단한 프로그래밍 문제입니다: 문자열을 입력으로 받아 첫 번째 단어를 찾아 반환하는 함수를 작성하세요. 함수가 문자열에서 공백을 찾지 못한다면, 문자열 전체가 하나의 단어일 것이므로 문자열 전체를 반환해야 합니다.

이 함수의 시그니처에 대해 생각해봅시다:

```rust
    fn first_word(s: &String) -> ?
```

이 함수 `first_word`는 매개변수로 `&String`을 가집니다. 소유권을 요구하지 않으므로 이는 괜찮습니다. 하지만 반환 타입은 무엇으로 해야 할까요? 문자열의 _일부_ 에 대해 표현하는 방법이 아직 없습니다. 대신, 단어의 끝에 해당하는 인덱스를 반환할 수는 있습니다. 아래 코드 스니펫에서 이를 한번 시도해봅시다.

```rust
    fn first_word(s: &String) -> usize {
        let bytes = s.as_bytes();

        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return i;
            }
        }

        s.len()
    }
```

##### 문자열 매개변수에 대한 바이트 인덱스 값을 반환하는 first_word 함수

`String`의 각 요소를 하나씩 확인하여 해당 값이 공백인지 검사해야 하기 때문에, `as_bytes` 메서드를 사용하여 `String`을 바이트 배열로 변환합니다:

```rust
    let bytes = s.as_bytes();
```

그 다음, `iter` 메서드를 사용하여 바이트 배열에서 이터레이터를 생성합니다:

```rust
    for (i, &item) in bytes.iter().enumerate() {
```

이터레이터에 대해 자세히 다룰 내용은 13장에서 논의할 것입니다. 지금은 `iter`가 컬렉션의 각 요소를 반환하는 메서드이며, `enumerate`는 `iter`의 결과를 감싸서 각 요소를 튜플 일부로 반환한다는 것만 알고 있으면 됩니다. `enumerate`로 반환된 튜플의 첫 번째 요소는 인덱스이고, 두 번째 요소는 요소에 대한 참조입니다. 이를 이용하면 직접 인덱스를 계산하는 것보다 더 편리합니다.

`enumerate` 메서드가 튜플을 반환하기 때문에, 해당 튜플을 패턴으로 구조 해체할 수 있습니다. `for` 루프에서 우리는 튜플의 인덱스를 나타내는 `i`와 해당 요소 바이트를 나타내는 `&item`으로 패턴을 지정합니다. `.iter().enumerate()`에서 요소에 대한 참조를 얻으므로 패턴 내에서 `&`를 사용합니다.

`for` 루프 내에서는 바이트 리터럴 문법을 사용하여 공백을 나타내는 바이트를 찾습니다. 공백을 찾으면 위치를 반환합니다. 찾지 못하면 `s.len()`을 사용하여 문자열의 길이를 반환합니다:

```rust
        if item == b' ' {
            return i;
        }
    }

    s.len()
```

이제 문자열에서 첫 번째 단어의 끝 인덱스를 찾아낼 수 있는 방법을 얻었지만, 문제가 있습니다. `usize`를 단독으로 반환하고 있는데, 이는 `&String`의 문맥에서만 의미 있는 숫자입니다. 즉, 반환된 값은 `String`과 분리된 값이기 때문에, 미래에 여전히 유효할 것이라는 보장이 없습니다. 아래의 코드 스니펫에서 이전 예제의 `first_word` 함수를 사용하는 프로그램을 살펴보세요.

```rust
    fn main() {
        let mut s = String::from("hello world");

        let word = first_word(&s); // word는 값 5를 갖습니다

        s.clear(); // 이 작업은 문자열을 비웁니다. 이제 ""와 같습니다.

        // word는 여전히 값 5를 갖고 있지만, 이 값 5와 의미 있게 사용될 
        // 문자열은 더 이상 존재하지 않습니다. word는 이제 완전히 유효하지 않습니다!
    }
```

##### first_word 함수의 결과 값을 저장하고 이후 문자열 내용을 변경

이 프로그램은 컴파일 오류 없이 컴파일되며, `s.clear()` 이후에 `word`를 사용할 수 있더라도 문제가 없습니다. `word`는 `s`의 상태와 연결되어 있지 않기 때문에 여전히 값 `5`를 포함합니다. 우리는 이 값 `5`와 변수 `s`를 사용하여 첫 번째 단어를 추출하려고 시도할 수 있겠지만, 이는 버그일 것입니다. 왜냐하면 우리가 `word`에 값을 저장한 이후로 `s`의 내용이 변경되었기 때문입니다.

`word`의 인덱스 값이 `s`의 데이터와 동기화되지 않게 되는 점을 걱정해야 하는 것은 번거롭고 오류를 유발하기 쉽습니다! `second_word` 함수처럼 또 다른 함수를 작성하면 이런 인덱스 관리가 훨씬 더 복잡해집니다. 그런 함수의 시그니처는 다음과 같아야 할 것입니다:

```rust
    fn second_word(s: &String) -> (usize, usize) {
```

이제 우리는 시작 인덱스와 끝 인덱스 둘 다를 추적해야 하고, 특정 상태의 데이터를 기반으로 계산된 값이지만 그 상태와 전혀 연결되어 있지 않은 값이 더욱 늘어나게 됩니다. 이제는 동기화해야 할 서로 관련 없는 세 개의 변수가 떠다니고 있는 셈입니다.

다행히도, 러스트에는 이 문제를 해결하는 방법이 있습니다: 문자열 슬라이스.