## 참조를 사용하여 값 빌리기

이전 과제의 튜플 코드에서의 문제는, `calculate_length`를 호출한 후에도 여전히 `String`을 사용하기 위해, `String`을 호출한 함수로 반환해야 한다는 점에 있습니다. 이는 `String`이 `calculate_length`로 이동되었기 때문입니다.

여기에서는 값을 소유권으로 가져가는 대신 객체에 대한 참조를 매개변수로 가지는 `calculate_length` 함수를 정의하고 사용하는 방법을 보여줍니다:

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

첫째로, 변수 선언과 반환 값에서 모든 튜플 코드가 사라졌다는 점에 주목하십시오. 둘째로, `calculate_length` 함수에 `&s1`을 전달하고, 함수 정의에서 `String` 대신 `&String`을 취한다는 점에 유의하십시오.

이 앰퍼샌드(`&`)는 _참조(reference)_를 나타내며, 소유권을 넘기지 않고 어떤 값에 접근할 수 있게 해줍니다. 그림 5는 이를 다이어그램으로 보여줍니다.

<img alt="&amp;String s가 String s1을 가리키는 다이어그램" src="https://doc.rust-lang.org/stable/book/img/trpl04-05.svg" class="center">

##### 그림 5: `&String s`가 `String s1`을 가리키는 다이어그램

> 참고: `&`를 사용하여 참조를 생성하는 것의 반대는 _역참조(dereferencing)_입니다. 이는 `*` 연산자로 수행됩니다. 역참조 연산자를 사용하는 몇 가지 예제는 8장에서 설명하며, 역참조의 자세한 내용은 15장에서 다룹니다.

이 함수 호출을 좀 더 자세히 살펴봅시다:

```rust
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
```

`&s1` 문법은 `s1`의 값을 _참조_하지만, 그것을 소유하지 않는 참조를 생성할 수 있게 해줍니다. 소유권이 없기 때문에 참조가 범위를 벗어난다고 해도 가리키는 값은 제거되지 않습니다.

마찬가지로 함수 서명에서도 `s` 매개변수 타입이 참조임을 나타내기 위해 `&`를 사용합니다. 사용법을 더 명확히 하기 위해 주석을 추가해 보겠습니다:

```rust
fn calculate_length(s: &String) -> usize { // s는 String에 대한 참조입니다.
    s.len()
} // 여기서 s는 범위를 벗어납니다. 그러나 참조하는 값을 소유하지 않기
  // 때문에 아무 일도 일어나지 않습니다.
```

변수 `s`가 유효한 범위는 다른 함수 매개변수의 범위와 동일하지만, 참조가 가리키는 값은 우리가 소유하고 있지 않기 때문에 범위를 벗어나더라도 삭제되지 않습니다. 함수가 실제 값 대신 참조를 매개변수로 가지는 경우, 소유권을 반환받기 위해 값을 반환할 필요가 없습니다. 처음부터 소유권을 넘겨받은 적이 없기 때문입니다.

참조를 함수 매개변수로 사용하는 것을 우리는 _빌리기(borrowing)_라고 부릅니다. 현실 세계에서 누군가의 물건을 빌리면, 사용한 후에는 돌려줘야 하는 것과 같습니다.