## 참조의 스코프

참조의 스코프는 그것이 도입된 지점부터 시작하여 마지막으로 사용된 지점까지 계속된다는 점을 유념하세요. 예를 들어, 이 코드는 불변 참조가 마지막으로 사용된 시점이 가변 참조가 도입되기 이전이기 때문에 컴파일됩니다:

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 문제 없음
    let r2 = &s; // 문제 없음
    println!("{} and {}", r1, r2);
    // r1과 r2는 이 지점 이후로 더 이상 사용되지 않음

    let r3 = &mut s; // 문제 없음
    println!("{}", r3);
```

불변 참조인 `r1`과 `r2`의 스코프는 마지막으로 사용된 `println!` 이후에 끝나며, 이는 가변 참조 `r3`가 생성되기 이전입니다. 이러한 스코프는 서로 겹치지 않으므로, 이 코드는 허용됩니다.  
컴파일러가 참조가 스코프의 끝 이전에 더 이상 사용되지 않는다는 것을 알아챌 수 있는 기능을 비사전적 수명(Non-Lexical Lifetimes, 줄여서 NLL)이라고 하며, 이에 대해 더 자세히 알고 싶다면 [The Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html)를 참조하세요.

비록 빌림 오류가 때로는 좌절감을 줄 수 있지만, 컴파일 타임에 Rust 컴파일러가 잠재적인 버그를 조기에 지적하고(런타임이 아닌) 정확히 문제가 있는 위치를 알려주고 있다는 점을 기억하세요. 이렇게 하면 데이터가 예상했던 결과와 다르게 된 이유를 추적할 필요가 없습니다.