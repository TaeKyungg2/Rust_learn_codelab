## 중복 없는 코드

다음 코드 스니펫에서는 가장 큰 숫자를 찾는 코드를 `largest`라는 이름의 함수로 추출했습니다. 이 섹션의 첫 번째 코드와 달리, 첫 번째 코드는 특정 리스트에서만 가장 큰 숫자를 찾을 수 있지만, 이번 프로그램은 두 개의 다른 리스트에서도 가장 큰 숫자를 찾을 수 있습니다.

```rust
fn largest(list: &[i32]) -> &i32 {
  let mut largest = &list[0];

  for item in list {
    if item > largest {
      largest = item;
    }
  }

  largest
}

fn main() {
  let number_list = vec![34, 50, 25, 100, 65];
  let result = largest(&number_list);
  println!("The largest number is {}", result);

  let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];
  let result = largest(&number_list);
  println!("The largest number is {}", result);
}
```

#### 두 리스트에서 가장 큰 숫자를 찾는 추상화된 코드

`largest` 함수에는 `list`라는 매개변수가 있는데, 이는 함수에 전달할 수 있는 임의의 `i32` 값 슬라이스를 나타냅니다. 따라서, 함수 호출 시 우리가 전달한 특정 값들에서 코드가 실행됩니다.

요약하면, 코드를 두 번째 목록에서 세 번째 목록으로 변경하기 위해 수행한 단계는 다음과 같습니다:

1. 중복 코드를 식별합니다.  
2. 중복된 코드를 함수 본문으로 추출하고 해당 코드의 입력값과 반환값을 함수 서명에 명시합니다.  
3. 중복된 코드가 있었던 두 인스턴스를 함수 호출로 업데이트합니다.  

다음으로, 이러한 동일한 단계를 제너릭을 사용하여 다양한 방식으로 코드 중복을 줄여보겠습니다. 함수 본문이 구체적인 값 대신 추상적인 `list`에서 작동할 수 있는 것과 마찬가지로, 제너릭은 코드가 추상적인 타입에서 작동하도록 해줍니다.

예를 들어, `i32` 값 슬라이스에서 가장 큰 항목을 찾는 함수와 `char` 값 슬라이스에서 가장 큰 항목을 찾는 함수가 있다고 가정해봅시다. 이러한 중복을 어떻게 제거할 수 있을까요? 알아봅시다!