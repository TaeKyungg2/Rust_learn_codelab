## 제네릭 타입, 트레이트, 그리고 라이프타임

모든 프로그래밍 언어는 개념의 중복을 효과적으로 처리하기 위한 도구를 가지고 있습니다. Rust에서는 그 중 하나로 *제네릭*을 사용합니다. 제네릭은 구체적인 타입이나 다른 속성을 대체하는 추상적인 대체물입니다. 우리가 코드를 작성할 때, 컴파일하고 실행할 때 무엇이 자리를 차지할지 모르는 상태에서 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있습니다.

함수가 알려지지 않은 값을 매개변수로 받아 동일한 코드를 여러 구체적인 값에 대해 실행하는 것과 비슷하게, 함수는 `i32`나 `String` 같은 구체적인 타입 대신 어떤 제네릭 타입의 매개변수를 받을 수 있습니다. 사실, 우리는 이미 "열거형" 장에서 `Option<T>`, "공통 컬렉션" 장에서 `Vec<T>`와 `HashMap<K, V>`, 그리고 "복구 가능 및 복구 불가능한 에러" 장에서 `Result<T, E>`와 함께 제네릭을 사용했습니다. 이번 장에서는 여러분 자신만의 타입, 함수, 그리고 메서드를 제네릭과 함께 정의하는 방법을 탐구할 것입니다!

먼저, 코드 중복을 줄이기 위해 함수를 추출하는 방법을 검토하겠습니다. 이후, 두 함수가 매개변수 타입만 다른 상황에서 동일한 기술을 사용하여 제네릭 함수를 만드는 법을 살펴보겠습니다. 또한, 구조체와 열거형 정의에서 제네릭 타입을 사용하는 방법도 설명하겠습니다.

그런 다음, *트레이트*를 사용하여 제네릭 방식으로 동작을 정의하는 방법을 배우게 됩니다. 트레이트와 제네릭 타입을 결합하여 특정 동작을 가진 타입에만 제네릭 타입을 제한하도록 할 수 있습니다.

마지막으로, 참조가 어떻게 서로 관련되는지에 대해 컴파일러에 정보를 제공하는 다양한 제네릭인 *라이프타임*을 논의할 것입니다. 라이프타임을 사용하면 많은 상황에서 값을 빌리는 것이 가능해지며, 동시에 참조가 유효한지를 컴파일러가 확인할 수 있도록 할 수 있습니다.