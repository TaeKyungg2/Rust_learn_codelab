### 메서드 정의에서의 라이프타임 애노테이션

라이프타임과 함께 구조체에 메서드를 구현할 때, "제너릭 데이터 타입" 섹션의 "구조체 정의와 다른 제너릭 타입을 사용하는 메서드" 예제에서 보여준 제너릭 타입 매개변수 구문과 동일한 구문을 사용합니다. 우리가 라이프타임 매개변수를 선언하고 사용하는 위치는 그것이 구조체 필드와 관련이 있는지, 아니면 메서드 매개변수 및 반환값과 관련이 있는지에 따라 달라집니다.

구조체 필드에 대한 라이프타임 이름은 항상 `impl` 키워드 뒤에 선언되어야 하며, 구조체의 이름 뒤에 사용되어야 합니다. 이는 해당 라이프타임이 구조체의 타입의 일부이기 때문입니다.

`impl` 블록 내부의 메서드 서명에서는 참조가 구조체 필드의 참조 라이프타임에 연결될 수도 있고 그렇지 않을 수도 있습니다. 또한, 라이프타임 생략 규칙 덕분에 메서드 서명에 라이프타임 애노테이션이 필요 없는 경우도 자주 있습니다. 앞서 이 섹션에서 정의한 `ImportantExcerpt`라는 구조체를 사용한 몇 가지 예제를 살펴보겠습니다.

먼저, 오직 `self`에 대한 참조 하나만 매개변수로 사용하고, 반환값이 아무 참조도 아닌 `i32`인 `level`이라는 메서드를 사용하겠습니다:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

`impl` 뒤의 라이프타임 매개변수 선언과 타입 이름 뒤의 사용은 필수이지만, 참조인 `self`의 라이프타임을 애노테이트할 필요는 없습니다. 이는 첫 번째 생략 규칙 덕분입니다.

다음은 세 번째 라이프타임 생략 규칙이 적용되는 예제입니다:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

여기에는 두 가지 입력 라이프타임이 있으므로, Rust는 첫 번째 라이프타임 생략 규칙을 적용하여 `&self`와 `announcement` 각각에 고유 라이프타임을 부여합니다. 그러고 나서 매개변수 중 하나가 `&self`이므로, 반환 타입은 `&self`의 라이프타임을 받게 되며, 모든 라이프타임이 처리됩니다.