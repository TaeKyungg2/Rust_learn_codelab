### 수명 생략(Lifetime Elision)

여러분은 모든 참조에는 수명이 있으며, 참조를 사용하는 함수나 구조체에 대해 수명 매개변수를 지정해야 한다는 것을 배웠습니다. 그러나 "소유권 이해하기"의 "슬라이스(Slices)" 섹션에서, `s` 매개변수의 타입으로 문자열 슬라이스를 사용하여 `first_word` 함수의 개선을 소개한 예제에서는 수명 애노테이션 없이 컴파일된 함수를 봤습니다. 이 함수는 아래에 다시 나와 있습니다.

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

#### "슬라이스"에서 우리가 정의한 함수는 수명 애노테이션 없이 컴파일되었음. 하지만 매개변수와 반환 타입이 참조임.

이 함수가 수명 애노테이션 없이 컴파일된 이유는 역사적으로 찾아볼 수 있습니다. 초기(1.0 이전) 러스트 버전에서는 이 코드가 컴파일되지 않았을 것입니다. 모든 참조는 명시적인 수명이 필요했기 때문입니다. 당시 함수 시그니처는 다음과 같이 작성되었어야 했습니다:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

많은 러스트 코드를 작성하면서 러스트 팀은 특정 상황에서 러스트 프로그래머들이 반복적으로 동일한 수명 애노테이션을 입력하고 있다는 것을 발견했습니다. 이러한 상황은 예측 가능했고 몇 가지 결정론적 패턴을 따랐습니다. 개발자들은 이러한 패턴을 컴파일러 코드에 프로그래밍하여 빌림 검사기가 이러한 상황에서 수명을 추론하고 명시적 애노테이션이 필요 없도록 만들었습니다.

이 러스트의 역사는 미래에도 더 많은 결정론적 패턴이 등장할 가능성과 함께 컴파일러에 추가될 수 있음을 암시합니다. 미래에는 더 적은 수명 애노테이션이 필요할 수도 있습니다.

러스트의 참조 분석에 프로그래밍된 이러한 패턴은 *수명 생략 규칙(lifetime elision rules)*이라고 합니다. 이것은 프로그래머가 따라야 할 규칙이 아니며, 컴파일러가 고려하는 특정 사례의 집합입니다. 그리고 여러분의 코드가 이 경우에 해당한다면 명시적으로 수명을 작성할 필요가 없습니다.

수명 생략 규칙은 완전한 추론을 제공하지 않습니다. 만약 러스트가 결정론적으로 이 규칙을 적용했음에도 참조의 수명이 무엇인지 여전히 모호할 경우, 컴파일러는 남은 참조들의 수명이 무엇이어야 하는지 추측하지 않습니다. 이 경우 컴파일러는 추측 대신 오류를 출력하며, 참조들 간의 관계를 지정하는 수명 애노테이션을 추가하여 이 문제를 해결해야 합니다.

함수나 메서드 매개변수의 수명은 *입력 수명(input lifetimes)*이라고 하며, 반환 값의 수명은 *출력 수명(output lifetimes)*이라고 합니다.

컴파일러는 명시적인 애노테이션이 없을 때 참조가 사용할 수명을 결정하기 위해 세 가지 규칙을 사용합니다. 첫 번째 규칙은 입력 수명에 적용되며, 두 번째와 세 번째 규칙은 출력 수명에 적용됩니다. 컴파일러가 세 가지 규칙을 모두 확인했음에도 여전히 수명을 결정할 수 없는 참조가 있으면, 컴파일러는 오류를 발생시키며 중단합니다. 이 규칙들은 `fn` 정의뿐만 아니라 `impl` 블록에도 적용됩니다.

첫 번째 규칙은 참조인 각 매개변수가 그 자체의 수명 매개변수를 가진다는 것입니다. 즉, 매개변수가 하나인 함수는 하나의 수명 매개변수를 가집니다: `fn foo<'a>(x: &'a i32)`; 매개변수가 두 개인 함수는 두 개의 별개 수명 매개변수를 가집니다: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)` 등등.

두 번째 규칙은 입력 수명 매개변수가 정확히 하나일 경우, 그 수명이 모든 출력 수명 매개변수에 할당됩니다: `fn foo<'a>(x: &'a i32) -> &'a i32`.

세 번째 규칙은 입력 수명 매개변수가 여러 개인 경우, 그중 하나가 `&self` 또는 `&mut self`일 때, 이는 메서드이므로 `self`의 수명이 모든 출력 수명 매개변수에 할당됩니다. 이 세 번째 규칙 덕분에 메서드를 읽거나 작성할 때 더 적은 기호로 간결하게 표현할 수 있습니다.

우리가 컴파일러 입장에서 `first_word` 함수의 서명에 있는 참조들의 수명을 결정하기 위해 이 규칙들을 적용한다고 가정해 봅시다. 서명은 초기에는 참조에 어느 수명도 할당되지 않은 상태로 시작합니다:

```rust,ignore
fn first_word(s: &str) -> &str {
```

그런 다음 컴파일러는 첫 번째 규칙을 적용하여 각 매개변수가 자신만의 수명을 가져야 한다고 지정합니다. 일반적으로 이 수명을 `'a`라고 부르므로 서명은 이제 다음과 같이 됩니다:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

두 번째 규칙이 적용됩니다. 입력 수명이 정확히 하나 있기 때문입니다. 두 번째 규칙에 따르면, 하나의 입력 매개변수의 수명이 출력 수명에 할당됩니다. 따라서 서명은 다음과 같이 됩니다:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

이제 이 함수 서명에 있는 모든 참조들은 수명을 가지게 되었으며, 컴파일러는 수명을 명시적으로 애노테이션하지 않아도 서명 분석을 계속 진행할 수 있습니다.

다른 예를 봅시다. 이번에는 Listing 10-21에서 처음 시작했을 때 수명 매개변수가 없는 `longest` 함수를 사용합니다:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

첫 번째 규칙을 적용해 봅시다: 각 매개변수가 자신만의 수명을 가집니다. 이번에는 매개변수가 하나가 아니라 두 개이므로 두 개의 수명이 있습니다:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

여기서 두 번째 규칙은 적용되지 않습니다. 입력 수명이 하나 이상 있기 때문입니다. 세 번째 규칙도 적용되지 않습니다. `longest`는 함수이지 메서드가 아니며, 매개변수 중에 `self`가 없기 때문입니다. 세 가지 규칙을 모두 검토한 후에도 여전히 반환 타입의 수명이 무엇인지 결정되지 않았습니다. 이 때문에 `longest` 함수를 처음 구현하려고 시도한 목록에서 코드 컴파일 중 오류가 발생했습니다. 컴파일러는 수명 생략 규칙을 통해 작업했지만, 서명에 있는 참조들의 모든 수명을 여전히 알아낼 수 없었습니다.

세 번째 규칙은 주로 메서드 서명에서만 적용되기 때문에, 메서드 서명에서 수명을 여전히 자주 애노테이션할 필요가 없는 이유를 살펴보기 위해 다음에는 이 맥락에서 수명을 살펴보겠습니다.