### 빌림 검사기

Rust 컴파일러는 *빌림 검사기*를 사용하여 스코프를 비교하고 모든 빌림이 유효한지 판단합니다. 아래 코드 예제는 이전 코드와 동일하지만, 변수의 생명주기를 나타내는 주석이 추가된 버전입니다.

```rust,ignore,does_not_compile
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

#### `r`과 `x`의 생명주기 주석, 각각 `'a`와 `'b`로 명명됨

여기서 우리는 `r`의 생명주기를 `'a`로, `x`의 생명주기를 `'b`로 주석 처리했습니다. 보시는 바와 같이 내부 `'b` 블록은 외부 `'a` 생명주기 블록보다 훨씬 작습니다. 컴파일 시 Rust는 두 생명주기의 크기를 비교하고, `r`의 생명주기가 `'a`라고 판단하지만 이것이 `'b` 생명주기를 갖는 메모리를 참조한다는 것을 인식합니다. 프로그램은 `'b`가 `'a`보다 짧기 때문에 거부됩니다. 즉, 참조의 대상이 참조 자체만큼 오래 존재하지 않습니다.

아래 예제는 코드에 dangling reference(댕글링 참조)가 없도록 수정했으며, 오류 없이 컴파일됩니다.

```rust
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
```

#### 데이터가 참조보다 더 긴 생명주기를 가지므로 유효한 참조

여기서는 `x`가 `'b` 생명주기를 가지며, 이번 경우 `'a`보다 더 깁니다. 이는 `r`이 `x`를 참조할 수 있음을 의미하며, Rust는 `r`의 참조가 `x`가 유효한 동안 항상 유효하다는 것을 알게 됩니다.

이제 참조의 생명주기가 어디에 있는지, 그리고 Rust가 생명주기를 분석하여 참조가 항상 유효하게 유지되도록 보장하는 방법을 알았으므로, 함수의 매개변수와 반환값 맥락에서 일반적인 생명주기를 탐구해보겠습니다.