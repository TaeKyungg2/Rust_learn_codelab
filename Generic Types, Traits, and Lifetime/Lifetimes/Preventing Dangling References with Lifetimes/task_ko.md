### 라이프타임을 사용해 댕글링 참조 방지하기

라이프타임의 주요 목표는 댕글링 참조(유효하지 않은 데이터를 참조하여 프로그램이 의도한 데이터와 다른 데이터를 참조하게 되는 경우)를 방지하는 것입니다. 아래 프로그램은 바깥쪽 스코프와 내부 스코프를 포함하고 있습니다.

```rust,ignore,does_not_compile
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
```

#### 스코프 밖으로 벗어난 값을 참조하려는 시도

> 참고: 이 코드와 이후 몇몇 예제에서는 변수를 선언할 때 초기값을 제공하지 않고, 변수 이름만 외부 스코프에 존재하도록 설정합니다. 얼핏 보면 이것이 러스트에서 null 값을 허용하지 않는다는 개념과 충돌하는 것처럼 보일 수 있습니다. 그러나 초기값 없이 변수를 사용하려고 하면 컴파일 타임 오류가 발생합니다. 이는 러스트가 실제로 null 값을 허용하지 않는다는 것을 보여줍니다.

외부 스코프에서는 초기값 없이 `r`이라는 변수를 선언하고, 내부 스코프에서는 초기값이 5인 `x` 변수를 선언합니다. 내부 스코프 안에서 `r`의 값을 `x`에 대한 참조로 설정하려고 시도합니다. 이후 내부 스코프가 끝나고, `r`에 저장된 값을 출력하려고 합니다. 하지만 이 코드는 컴파일되지 않습니다. 그 이유는 `r`이 참조하고 있는 값이 우리가 사용하기 전에 스코프 바깥으로 벗어났기 때문입니다. 아래는 오류 메시지입니다:

```console
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!("r: {}", r);
   |                           - borrow later used here
```

변수 `x`가 "충분히 오래 살지 않는다"는 메시지가 나옵니다. 그 이유는 내부 스코프가 7번째 줄에서 끝나는 시점에 `x`가 스코프 밖으로 벗어나게 되기 때문입니다. 그러나 `r`은 외부 스코프에서 여전히 유효합니다. 외부 스코프는 내부 스코프보다 더 넓은 범위를 갖기 때문에 우리는 `r`이 "더 오래 산다"고 표현합니다. 만약 러스트가 이 코드를 허용한다면, `r`은 `x`가 스코프에서 벗어나 메모리 해제된 상태의 메모리를 참조하게 됩니다. 그 결과, `r`로 어떤 작업을 시도하든 올바르게 동작하지 않을 것입니다. 그렇다면 러스트는 이 코드가 유효하지 않음을 어떻게 판단할까요? 러스트는 이를 차용 검사기(borrow checker)를 사용해 확인합니다.