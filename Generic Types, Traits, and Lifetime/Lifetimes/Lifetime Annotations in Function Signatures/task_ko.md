### 함수 시그니처에서의 라이프타임 어노테이션

이제 `longest` 함수 문맥에서 라이프타임 어노테이션을 살펴보겠습니다. 제너릭 타입 매개변수와 마찬가지로, 함수 이름과 매개변수 리스트 사이에 꺾쇠 괄호 안에 제너릭 라이프타임 매개변수를 선언해야 합니다. 이 시그니처에서 표현하고자 하는 제약은 매개변수와 반환값의 모든 참조가 동일한 라이프타임을 가져야 한다는 점입니다. 라이프타임을 `'a`라고 이름 짓고, 아래 코드 스니펫과 같이 각 참조에 추가합니다.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

#### 모든 시그니처 참조가 동일한 라이프타임 `'a`를 가져야 함을 명시하는 `longest` 함수 정의

이 코드는 컴파일되어 우리가 원하는 결과를 생성해야 하며, `main` 함수에서 `longest` 함수를 호출하여 두 문자열 슬라이스 중 더 긴 것을 찾는 예제와 함께 사용할 수 있습니다.

함수 시그니처는 이제 Rust에게 어떤 라이프타임 `'a` 동안 함수가 두 개의 매개변수를 받으며, 이 매개변수는 모두 최소한 라이프타임 `'a`만큼 살아 있는 문자열 슬라이스임을 알려줍니다. 또한, 함수 시그니처는 함수에서 반환되는 문자열 슬라이스가 최소한 라이프타임 `'a`만큼 살아 있음을 Rust에게 알려줍니다. 실질적으로는 `longest` 함수에서 반환되는 참조의 라이프타임이 매개변수로 전달된 참조들 중 더 짧은 라이프타임과 동일하다는 것을 의미합니다. 이러한 제약은 Rust가 강제하기를 원하는 사항들입니다. 이 함수 시그니처에 라이프타임 매개변수를 지정할 때, 전달되거나 반환된 값들의 라이프타임을 변경하는 것이 아닙니다. 대신, 이러한 제약을 따르지 않는 값을 빌림 검사기(borrow checker)가 거부하도록 지정하는 것입니다. `longest` 함수는 `x`와 `y`가 실제로 얼마나 오래 살아 있는지 정확히 알 필요가 없으며, 이 시그니처를 만족하는 `'a`에 해당하는 어떤 스코프가 대체될 수 있음을 알면 됩니다.

함수에 라이프타임을 어노테이션할 때, 어노테이션은 함수 본문이 아닌 함수 시그니처에 들어갑니다. Rust는 함수 내부 코드를 분석할 때 도움이 필요하지 않습니다. 하지만 함수가 함수 외부 코드와 참조를 공유하거나 반환할 때, Rust가 매개변수나 반환값의 라이프타임을 스스로 이해하는 건 거의 불가능에 가깝습니다. 함수가 호출될 때마다 라이프타임은 다를 수 있습니다. 이러한 이유로 라이프타임을 수동으로 어노테이션해야 합니다.

구체적인 참조를 `longest`에 전달할 때, `'a`에 대체되는 실제 라이프타임은 `x`와 `y`의 스코프가 겹치는 부분입니다. 즉, 제너릭 라이프타임 `'a`는 `x`와 `y`의 라이프타임 중 더 짧은 라이프타임과 동일한 구체적인 라이프타임을 갖습니다. 반환 값에 동일한 라이프타임 매개변수 `'a`를 어노테이션했기 때문에, 반환된 참조는 `x`와 `y`의 라이프타임 중 더 짧은 라이프타임 동안에도 유효합니다.

라이프타임 어노테이션이 `longest` 함수에 어떻게 제약을 가하는지, 서로 다른 구체적인 라이프타임을 가진 참조를 전달해 보여주겠습니다. 아래 코드는 간단한 예제입니다.

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

#### 서로 다른 구체적인 라이프타임을 가진 `String`값 참조와 함께 `longest` 함수 사용

이 예제에서 `string1`은 바깥 스코프 끝까지 유효하고, `string2`는 내부 스코프 끝까지 유효합니다. 그리고 `result`는 내부 스코프 끝까지 유효한 어떤 값을 참조합니다. 이 코드를 실행하면 빌림 검사기가 이 코드를 문제없이 승인함을 알 수 있습니다. 코드는 컴파일되어 `The longest string is long string is long`이라는 결과를 출력합니다.