### 메서드 정의에서

구조체와 열거형 (이전에 "Structs" 챕터에서 다뤘던 것처럼)에 메서드를 구현하고, 메서드 정의에 제네릭 타입을 사용할 수도 있습니다. 아래 코드 스니펫은 앞서 정의한 `Point<T>` 구조체에 `x`라는 이름의 메서드가 구현된 예를 보여줍니다.

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

#### `T` 타입의 `x` 필드에 대한 참조를 반환하는 `Point<T>` 구조체에 `x`라는 메서드를 구현하기

여기서 우리는 `Point<T>`에 `x`라는 이름의 메서드를 정의했으며, 이는 `x` 필드의 데이터를 참조 형태로 반환합니다.

`impl` 뒤에 바로 `T`를 선언해야 우리가 `Point<T>` 타입에 메서드를 구현하고 있음을 명시할 수 있다는 점에 유의하세요. `impl` 뒤에 제네릭 타입인 `T`를 선언함으로써, Rust는 `Point`의 꺾쇠 괄호 안에 있는 타입이 구체적인 타입이 아닌 제네릭 타입임을 인식할 수 있습니다.

예를 들어, 모든 제네릭 타입에 대해 `Point<T>` 인스턴스가 아닌, `Point<f32>` 인스턴스에만 메서드를 구현할 수도 있습니다. 아래에서는 구체적인 타입인 `f32`를 사용하며, 따라서 `impl` 뒤에 타입을 선언하지 않습니다.

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

#### 제네릭 타입 매개변수 `T`를 특정 구체적인 타입으로 가진 구조체에만 적용되는 `impl` 블록

이 코드는 `Point<f32>` 타입이 `distance_from_origin`이라는 메서드를 가지지만, `T`가 `f32`가 아닌 다른 타입일 경우에는 해당 메서드가 정의되지 않음을 의미합니다. 이 메서드는 점이 (0.0, 0.0) 좌표에서 얼마나 떨어져 있는지를 측정하며, 이는 부동소수점 타입에만 제공되는 수학적 연산을 사용합니다.