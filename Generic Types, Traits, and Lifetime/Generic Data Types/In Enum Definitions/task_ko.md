### Enum 정의에서

구조체를 다룬 것처럼, 열거형(enum)도 각 변형에 제네릭 데이터 타입을 포함하도록 정의할 수 있습니다. 표준 라이브러리가 제공하며 "열거형" 장에서 사용했던 `Option<T>` 열거형을 다시 살펴봅시다:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

이 정의가 이제 더 이해될 것입니다. 보시다시피, `Option<T>`는 타입 `T`에 대해 제네릭한 열거형이며, 두 가지 변형을 가집니다: 하나는 타입 `T`의 값을 포함하는 `Some`이고, 다른 하나는 어떤 값도 포함하지 않는 `None` 변형입니다. `Option<T>` 열거형을 사용하면 선택적 값을 가진다는 추상적인 개념을 표현할 수 있습니다. 또한, `Option<T>`가 제네릭하기 때문에 선택적 값의 타입에 상관없이 이 추상을 사용할 수 있습니다.

열거형은 여러 제네릭 타입도 사용할 수 있습니다. "복구 가능 및 복구 불가능한 오류" 장에서 사용한 `Result` 열거형의 정의가 한 가지 예입니다:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` 열거형은 두 가지 타입, `T`와 `E`에 대해 제네릭하며, 두 가지 변형을 가집니다: 타입 `T`의 값을 포함하는 `Ok`와 타입 `E`의 값을 포함하는 `Err`입니다. 이 정의는, 어떤 연산이 성공(어떠한 타입 `T`의 값을 반환)하거나 실패(어떠한 타입 `E`의 오류를 반환)할 가능성이 있는 경우 어디서든 `Result` 열거형을 사용하기 편리하게 만들어줍니다. 실제로, "파일 열기" 코드 스니펫(“오류 처리” 장의 "Result로 복구 가능한 오류 처리" 섹션)에서 파일을 열 때, 파일이 성공적으로 열릴 경우 `T`는 `std::fs::File` 타입으로 채워졌고, 파일 열기에 문제가 있을 경우 `E`는 `std::io::Error` 타입으로 채워졌습니다.

여러 구조체나 열거형 정의가 포함된 코드에서 포함된 값의 타입만 다를 경우, 제네릭 타입을 사용하여 중복을 피할 수 있다는 점을 인식할 수 있습니다.