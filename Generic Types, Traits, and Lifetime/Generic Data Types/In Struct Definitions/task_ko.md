### 구조체 정의에서

`<>` 문법을 사용하여 하나 이상의 필드에 제네릭 타입 매개변수를 사용하는 구조체를 정의할 수도 있습니다. 아래 코드는 `x`와 `y` 좌표값을 어떤 타입이든 저장할 수 있는 `Point<T>` 구조체를 정의하는 방법을 보여줍니다.

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

#### `T` 타입의 `x`와 `y` 값을 저장하는 `Point<T>` 구조체

구조체 정의에서 제네릭을 사용하는 문법은 함수 정의에서 사용하는 것과 비슷합니다. 먼저, 구조체 이름 뒤의 꺾쇠 괄호 안에 타입 매개변수를 선언합니다. 그런 다음, 구조체 정의에서 콘크리트 데이터 타입을 지정하는 대신 제네릭 타입을 사용할 수 있습니다.

`Point<T>`를 정의할 때 하나의 제네릭 타입만 사용했기 때문에, 이 정의는 `Point<T>` 구조체가 특정 타입 `T`에 대해 제네릭하게 작동하며, 필드 `x`와 `y`는 같은 타입이라는 것을 나타냅니다. 만약 `Point<T>`의 인스턴스를 만들 때 아래와 같이 다른 타입의 값을 넣으려고 하면, 코드는 컴파일되지 않습니다.

```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

#### `x`와 `y` 필드는 동일한 제네릭 데이터 타입 `T`를 사용하므로 같은 타입이어야 합니다.

이 예제에서는 `x`에 정수 값 5를 할당할 때, 컴파일러에게 이 `Point<T>` 인스턴스에서 제네릭 타입 `T`가 정수가 될 것임을 알려줍니다. 그런 다음 `y`에 4.0을 지정하면, `x`와 동일한 타입이어야 한다고 정의했기 때문에 타입 불일치 오류가 발생합니다. 오류 메시지는 다음과 같습니다:

```console
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number
```

`x`와 `y`가 둘 다 제네릭이지만 서로 다른 타입일 수 있는 `Point` 구조체를 정의하려면 여러 제네릭 타입 매개변수를 사용할 수 있습니다. 예를 들어, 아래 코드에서는 `Point` 정의를 타입 `T`와 `U`에 대해 제네릭하게 바꿔, `x`는 타입 `T`, 그리고 `y`는 타입 `U`로 설정합니다.

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

#### 두 타입에 대해 제네릭한 `Point<T, U>`: `x`와 `y`가 서로 다른 타입일 수 있도록 설정

이제 위의 모든 `Point` 인스턴스가 허용됩니다! 정의에서 원하는 만큼 많은 제네릭 타입 매개변수를 사용할 수 있지만, 너무 많은 매개변수를 사용하면 코드가 읽기 어려워질 수 있습니다. 코드에서 많은 제네릭 타입을 사용할 필요가 있다면, 코드를 더 작은 단위로 구성하여 재구조화해야 할 가능성이 있습니다.