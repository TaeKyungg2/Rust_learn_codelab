### 제네릭을 사용하는 코드의 성능

제네릭 타입 매개변수를 사용할 때 실행 시간에 비용이 발생하는지 궁금할 수 있습니다. 좋은 소식은 Rust가 제네릭을 구현하는 방식 덕분에 제네릭 타입을 사용하는 코드가 구체적인 타입을 사용하는 코드보다 실행 속도가 느리지 않다는 점입니다.

Rust는 컴파일 시 코드에 대해 **단형화(monomorphization)**를 수행하여 이를 달성합니다. *단형화*란, 컴파일 시 사용된 구체적인 타입을 채워 넣어 제네릭 코드를 특정 코드로 변환하는 과정입니다.

이 과정에서 컴파일러는 이 섹션의 세 번째 코드 스니펫에서 제네릭 함수를 생성하기 위해 사용했던 단계와 반대 동작을 수행합니다. 즉, 컴파일러는 제네릭 코드가 호출된 모든 위치를 검토하여, 해당 제네릭 코드가 호출된 구체적인 타입에 대해 코드를 생성합니다.

표준 라이브러리의 `Option<T>` 열거형을 사용하는 예제를 통해 이 과정을 살펴보겠습니다:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Rust가 이 코드를 컴파일할 때, 단형화를 수행합니다. 이 과정에서 컴파일러는 `Option<T>` 인스턴스에 사용된 값을 확인하고, 두 가지 종류의 `Option<T>`를 식별합니다: 하나는 `i32`이고 다른 하나는 `f64`입니다. 따라서 컴파일러는 `Option<T>`의 제네릭 정의를 `Option_i32`와 `Option_f64`로 확장하여 제네릭 정의를 구체적인 정의로 대체합니다.

단형화된 코드 버전은 다음과 같습니다. 제네릭 `Option<T>`는 컴파일러가 생성한 구체적인 정의로 대체됩니다:

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Rust는 제네릭 코드를 각 인스턴스에서 타입을 지정하는 코드로 컴파일하기 때문에, 제네릭을 사용하는 데 따른 실행 시간 비용이 없습니다. 코드가 실행될 때는, 마치 각 정의를 수동으로 복제한 것처럼 동작합니다. 단형화 과정은 Rust의 제네릭이 런타임에서 매우 효율적으로 작동하도록 만듭니다.