### 제너릭 타입 혼합하기

구조체 정의에서 사용하는 제너릭 타입 매개변수가 해당 구조체의 메서드 서명에서 사용하는 것과 항상 동일하지는 않습니다. 예를 들어, 아래 예제는 이 섹션의 앞부분에서 나왔던 `Point<T, U>` 구조체에 대해 `mixup` 메서드를 정의합니다. 이 메서드는 또 다른 `Point`를 매개변수로 받는데, 이는 우리가 `mixup`을 호출하는 `self` `Point`와 다른 타입일 수 있습니다. 이 메서드는 `self` `Point`의 `x` 값(타입 `T`)과 전달받은 `Point`의 `y` 값(타입 `W`)을 사용하여 새 `Point` 인스턴스를 생성합니다.

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

#### 구조체 정의와 다른 제너릭 타입을 사용하는 메서드

`main`에서 우리는 `x`에 `i32` 타입(값 `5`)을 가지고, `y`에 `f64` 타입(값 `10.4`)을 가진 `Point`를 정의했습니다. `p2` 변수는 `x`에 문자열 슬라이스(값 `"Hello"`)를 가지고, `y`에 `char`(값 `c`)을 가진 `Point` 구조체입니다. `p1`에 대해 `p2`를 인수로 `mixup`을 호출하면 `p3`를 얻을 수 있습니다. 여기서 `p3`는 `x`가 `p1`에서 왔기 때문에 `i32` 타입을 가지며, `y`는 `p2`에서 왔기 때문에 `char` 타입을 가집니다. `println!` 매크로 호출은 `p3.x = 5, p3.y = c`를 출력합니다.

이 예제의 목적은 일부 제너릭 매개변수가 `impl`과 함께 선언되고, 다른 일부는 메서드 정의와 함께 선언되는 상황을 보여주는 것입니다. 여기서 `T`와 `U` 제너릭 매개변수는 구조체 정의와 관련이 있기 때문에 `impl` 뒤에 선언되었습니다. 반면 `V`와 `W` 제너릭 매개변수는 메서드에만 관련이 있기 때문에 `fn mixup` 뒤에 선언되었습니다.