### Trait Bound를 사용하여 조건적으로 메서드 구현하기

`impl` 블록에서 제네릭 타입 매개변수를 사용하는 트레이트 바운드를 통해, 특정 트레이트를 구현한 타입에 대해 조건적으로 메서드를 구현할 수 있습니다. 예를 들어, 아래 예시에 나오는 `Pair<T>` 타입은 항상 `new` 함수를 구현합니다. 그러나 `Pair<T>`는 내부 타입 `T`가 비교를 가능하게 해주는 `PartialOrd` 트레이트 *및* 출력을 가능하게 해주는 `Display` 트레이트를 구현하는 경우에만 `cmp_display` 메서드를 구현합니다.

```rust,noplayground
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

#### 제네릭 타입에서 트레이트 바운드에 따라 메서드를 조건적으로 구현하기

다른 트레이트를 구현한 타입에 대해 조건적으로 트레이트를 구현할 수도 있습니다. 트레이트 바운드를 만족하는 모든 타입에 대한 트레이트의 구현을 *블랭킷 구현(blanket implementation)*이라고 하며, 이는 Rust 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어, 표준 라이브러리는 `Display` 트레이트를 구현하는 모든 타입에 대해 `ToString` 트레이트를 구현합니다. 표준 라이브러리에서의 `impl` 블록은 다음 코드와 비슷합니다:

```rust,ignore
impl<T: Display> ToString for T {
    // --생략--
}
```

표준 라이브러리에 이러한 블랭킷 구현이 있기 때문에, `Display` 트레이트를 구현하는 모든 타입에서 `ToString` 트레이트에 정의된 `to_string` 메서드를 호출할 수 있습니다. 예를 들어, 정수는 `Display`를 구현하기 때문에 이를 문자열로 변환할 수 있습니다:

```rust
let s = 3.to_string();
```

블랭킷 구현은 트레이트 문서의 “Implementors” 섹션에서 확인할 수 있습니다.

트레이트와 트레이트 바운드는 제네릭 타입 매개변수를 사용하여 중복을 줄일 수 있도록 코드를 작성하면서도, 컴파일러에 제네릭 타입이 특정 동작을 가지도록 요구할 수 있게 합니다. 컴파일러는 트레이트 바운드 정보를 활용해, 우리의 코드에서 사용된 모든 구체적인 타입이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적 타입 언어에서는, 메서드를 정의하지 않은 타입에서 메서드를 호출했을 때 런타임 오류가 발생하게 됩니다. 하지만 Rust는 이러한 오류를 컴파일 타임으로 이동시키므로, 코드가 실행되기 전에 문제를 해결하도록 강제합니다. 또한, 컴파일 타임에 이미 동작을 확인했기 때문에 런타임에서 해당 동작을 확인하는 코드를 작성할 필요도 없습니다. 이를 통해 제네릭의 유연성을 포기하지 않으면서도 성능을 개선할 수 있습니다.