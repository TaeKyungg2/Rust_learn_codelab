## 코드의 동시 실행을 위한 스레드 사용

대부분의 현대 운영 체제에서 실행된 프로그램의 코드는 _프로세스_ 안에서 실행되며, 운영 체제는 여러 프로세스를 동시에 관리합니다. 프로그램 내에서도 독립적인 부분을 동시에 실행할 수 있습니다. 이러한 독립적인 부분을 실행하는 기능은 _스레드(thread)_ 라고 합니다.

프로그램의 연산을 여러 스레드로 나누면 성능이 향상될 수 있습니다. 프로그램이 동시에 여러 작업을 수행하기 때문입니다. 하지만 이는 복잡성을 더할 수도 있습니다. 스레드가 동시에 실행될 수 있기 때문에 서로 다른 스레드에서 실행되는 코드의 실행 순서는 보장되지 않습니다. 이는 다음과 같은 문제를 일으킬 수 있습니다:

*   서로 다른 순서로 데이터나 리소스에 접근하여 일관성이 없는 상태를 초래하는 레이스 컨디션(race conditions)
*   두 스레드가 서로 다른 스레드가 가지고 있는 리소스가 해제되기를 기다리며, 둘 다 진행하지 못하는 교착 상태(deadlocks)
*   특정 상황에서만 발생하고 재현하거나 수정하기 어려운 버그

러스트는 스레드 사용의 부정적인 영향을 최소화하려고 노력하지만, 멀티스레드 환경에서의 프로그래밍은 여전히 신중한 사고와 단일 스레드에서 실행되는 프로그램과는 다른 코드 구조를 요구합니다.

프로그래밍 언어는 다양한 방식으로 스레드를 구현합니다. 많은 운영 체제는 새 스레드를 생성하기 위한 API를 제공합니다. 언어가 운영 체제 API를 호출하여 스레드를 생성하는 이 모델은 때때로 _1:1 모델_ 이라고 불립니다. 이는 언어의 스레드 하나당 운영 체제 스레드 하나가 대응되기 때문입니다.

많은 프로그래밍 언어는 고유의 특별한 스레드 구현을 제공합니다. 이러한 언어 제공 스레드는 _그린 스레드(green threads)_ 라고 불리며, 이런 그린 스레드를 사용하는 언어는 이를 서로 다른 수의 운영 체제 스레드 맥락에서 실행합니다. 그래서 그린 스레드 모델은 _M:N 모델_ 이라고 불립니다. 여기서 `M`은 그린 스레드의 수, `N`은 운영 체제 스레드의 수를 나타내며, `M`과 `N`이 반드시 같은 숫자는 아닙니다.

각 모델은 고유한 장점과 단점을 가지고 있으며, 러스트에게 가장 중요한 트레이드오프는 런타임(runtime) 지원입니다. _런타임_ 은 혼란스러운 용어이며, 맥락에 따라 다양한 의미를 가질 수 있습니다.

이 문맥에서 _런타임_ 이란 언어가 각 바이너리에 포함시키는 코드를 의미합니다. 이 코드는 언어에 따라 크거나 작을 수 있지만, 어셈블리 언어가 아닌 모든 언어에는 어느 정도의 런타임 코드가 포함됩니다. 따라서 사람들이 "런타임이 없다(no runtime)"라고 말할 때 흔히 "작은 런타임(small runtime)"을 의미합니다. 작은 런타임은 기능이 적은 대신, 더 작은 바이너리를 생성하여 언어를 다양한 맥락에서 다른 언어와 결합하기 쉽게 만듭니다. 많은 언어는 더 많은 기능을 위해 런타임 크기를 증가시키는 데 만족하지만, 러스트는 거의 없는 런타임을 유지해야 하며 C 호출과 성능 유지를 위해 이를 포기할 수 없습니다.

그린 스레딩 M:N 모델은 스레드를 관리하기 위해 더 큰 언어 런타임이 필요합니다. 따라서 러스트 표준 라이브러리는 1:1 스레딩 구현만 제공합니다. 러스트처럼 낮은 수준의 언어에는 추가적인 오버헤드를 감수하면서도 특정 스레드의 실행 제어나 문맥 전환 비용 절감과 같은 측면을 위해 M:N 스레딩을 구현한 크레이트가 존재합니다.

이제 러스트에서 스레드를 정의했으니, 표준 라이브러리가 제공하는 스레드 관련 API를 사용하는 방법을 탐구해봅시다.