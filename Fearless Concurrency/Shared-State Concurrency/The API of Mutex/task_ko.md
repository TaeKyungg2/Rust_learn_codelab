#### Mutex<T>의 API

뮤텍스를 사용하는 방법의 예로, 아래에 표시된 것처럼 단일 스레드 컨텍스트에서 뮤텍스를 사용해 보겠습니다:

```rust
    use std::sync::Mutex;

    fn main() {
        let m = Mutex::new(5);

        {
            let mut num = m.lock().unwrap();
            *num = 6;
        }

        println!("m = {:?}", m);
    }
```

##### 단일 스레드 컨텍스트에서의 Mutex<T> API 탐구

다양한 타입들과 마찬가지로, `Mutex<T>`는 연관 함수 `new`를 사용하여 생성합니다. 뮤텍스 내부의 데이터에 접근하기 위해서는 `lock` 메서드를 사용하여 잠금을 획득합니다. 이 호출은 현재 스레드를 블록하여, 잠금을 획득할 차례가 될 때까지 작업을 할 수 없게 만듭니다.

만약 다른 스레드가 잠금을 보유한 상태에서 패닉이 발생하면, `lock` 호출이 실패합니다. 이 경우, 아무도 잠금을 획득할 수 없게 되므로, 이 상황에서는 `unwrap`을 사용하여 이 스레드도 패닉하도록 선택했습니다.

잠금을 획득한 후에는 반환값(이 경우 `num`으로 명명됨)을 뮤터블 참조로 처리하여 내부 데이터를 수정할 수 있습니다. 타입 시스템은 우리가 `m`의 값을 사용하기 전에 잠금을 반드시 획득하도록 보장합니다. `Mutex<i32>`는 `i32`가 아니기 때문에, `i32` 값을 사용하려면 잠금을 _반드시_ 획득해야 합니다. 실수로 잊을 수 없으며, 타입 시스템이 내부 `i32`에 접근하지 못하도록 막습니다.

짐작할 수 있듯이, `Mutex<T>`는 스마트 포인터입니다. 보다 정확히 말하자면, `lock` 호출은 `LockResult`로 래핑된 `MutexGuard`라는 스마트 포인터를 _반환_합니다. 이 `LockResult`는 우리가 `unwrap` 호출로 처리했습니다. `MutexGuard` 스마트 포인터는 내부 데이터에 포인터 역할을 하기 위해 `Deref`를 구현하며, 또한 `Drop` 구현을 가지고 있어 `MutexGuard`가 스코프를 벗어날 때 잠금을 자동으로 해제합니다. 이는 이전 코드 스니펫의 내부 스코프가 끝날 때 발생합니다. 그 결과, 우리는 잠금 해제를 잊어 다른 스레드가 뮤텍스를 사용하는 것을 막을 위험을 피할 수 있습니다. 잠금 해제는 자동으로 이루어지기 때문입니다.

잠금을 드롭한 후에는 뮤텍스 값을 출력하여 내부의 `i32`를 6으로 변경했음을 확인할 수 있습니다.