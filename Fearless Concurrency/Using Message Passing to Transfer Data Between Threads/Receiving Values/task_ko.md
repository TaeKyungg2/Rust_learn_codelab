## 값 수신하기

다음 예제에서는 메인 스레드에서 채널의 수신 측으로부터 값을 받는 과정을 보여줍니다. 이는 마치 강 끝에서 물속의 고무 오리를 건져 올리거나 채팅 메시지를 받는 것과 같습니다.

```rust
    use std::thread;
    use std::sync::mpsc;

    fn main() {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            let val = String::from("hi");
            tx.send(val).unwrap();
        });

        let received = rx.recv().unwrap();
        println!("Got: {}", received);
    }
```

##### 메인 스레드에서 "hi" 값을 수신하고 출력하기

채널의 수신 측에는 유용한 두 가지 메서드가 있습니다: `recv`와 `try_recv`. 여기서는 메서드 _receive_의 약자인 `recv`를 사용했습니다. 이 메서드는 메인 스레드의 실행을 차단(blocking)하며, 채널을 통해 값이 전송될 때까지 기다립니다. 값이 전송되면, `recv`는 `Result<T, E>` 형태로 해당 값을 반환합니다. 채널의 전송 측이 닫히면, 더 이상 전달받을 값이 없다는 신호로 에러를 반환합니다.

`try_recv` 메서드는 차단하지 않으며, 대신 즉시 `Result<T, E>`를 반환합니다: 메시지가 있을 경우 메시지를 포함한 `Ok` 값을 반환하고, 현재 메시지가 없으면 `Err` 값을 반환합니다. `try_recv`는 메시지를 기다리는 동안 이 스레드가 다른 작업을 할 필요가 있는 경우 유용합니다. 우리는 루프를 작성하여 주기적으로 `try_recv`를 호출하고, 메시지가 있으면 처리하며, 메시지가 없으면 잠시 다른 작업을 한 후 다시 확인할 수 있습니다.

이 예제에서는 단순성을 위해 `recv`를 사용했습니다. 메인 스레드에서 다른 작업을 수행할 필요 없이 메시지를 기다리는 것만 하면 되므로, 메인 스레드를 차단하는 방식이 적절합니다.

아래 코드 스니펫을 실행하면, 메인 스레드에서 값을 출력한 결과를 확인할 수 있습니다:

```text
    Got: hi
```

완벽합니다!