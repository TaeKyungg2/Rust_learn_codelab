## 소개

1972년 에세이 “겸손한 프로그래머(The Humble Programmer)”에서 Edsger W. Dijkstra는 “프로그램 테스트는 버그의 존재를 보여주는 데는 매우 효과적일 수 있지만, 버그가 없음을 보여주는 데는 절망적으로 부족하다”고 말했습니다. 하지만 그렇다고 해서 우리가 할 수 있는 만큼 테스트를 하지 말아야 한다는 뜻은 아닙니다!

프로그램의 정확성(corrections)이란, 코드가 우리가 의도한 대로 동작하는 정도를 의미합니다. Rust는 프로그램의 정확성에 대해 고도로 신경을 쓰도록 설계되었지만, 정확성은 복잡하며 쉽게 증명할 수 있는 것이 아닙니다. Rust의 타입 시스템은 이러한 부담의 큰 부분을 담당하고 있지만, 타입 시스템이 모든 종류의 잘못된 동작을 잡아낼 수는 없습니다. 따라서 Rust는 언어 내에서 자동화된 소프트웨어 테스트를 작성하는 것을 지원합니다.

예를 들어, `add_two`라는 함수를 작성했다고 가정해봅시다. 이 함수는 전달된 숫자에 2를 더합니다. 이 함수의 시그니처는 정수를 매개변수로 받고 정수를 결과로 반환합니다. 이 함수를 구현하고 컴파일할 때, 지금까지 배운 것처럼 Rust는 우리가 `String` 값을 전달하거나 잘못된 참조를 전달하지 않도록 타입 검사와 차용(borrow) 검사를 수행합니다. 하지만 Rust는 이 함수가 우리가 의도한 대로 정확히 동작할 것이라고, 즉 매개변수에 2를 더한 값을 반환할 것인지, 아니면 매개변수에 10을 더하거나 50을 뺀 값을 반환하지 않을 것인지 *확인할 수는 없습니다* 이상이 테스트의 영역입니다.  

예를 들어, 우리가 `3`을 `add_two` 함수에 전달했을 때 반환값이 `5`인지 단언(assert)하는 테스트를 작성할 수 있습니다. 코드를 변경할 때마다 이 테스트를 실행하여 기존의 올바른 동작이 변경되지 않았는지 확인할 수 있습니다.  

테스트는 복잡한 기술입니다. 이 한 챕터에서 좋은 테스트를 작성하는 방법의 모든 세부사항을 다룰 수는 없지만, Rust의 테스트 기능 기법에 대해 이야기할 것입니다. 테스트 작성 시 사용할 수 있는 애너테이션(annotation)과 매크로(macros), 테스트 실행 시 제공되는 기본 동작과 옵션, 그리고 테스트를 단위 테스트(unit test)와 통합 테스트(integration test)로 조직하는 방법을 다룰 예정입니다.