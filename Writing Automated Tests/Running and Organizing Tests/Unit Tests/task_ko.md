### 단위 테스트

단위 테스트의 목적은 코드의 각 단위를 나머지 코드와 분리하여 테스트함으로써 코드를 예상대로 작동하는 부분과 그렇지 않은 부분을 빠르게 찾아내는 것입니다. 단위 테스트는 *src* 디렉토리의 각 파일에 해당 파일에서 테스트할 코드와 함께 작성합니다. 관례적으로, 테스트 함수를 포함하는 `tests`라는 이름의 모듈을 각 파일에 생성하며, 해당 모듈에 `#[cfg(test)]` 어노테이션을 추가합니다.

#### 테스트 모듈과 `#[cfg(test)]`

테스트 모듈에 사용된 `#[cfg(test)]` 어노테이션은 Rust에게 `cargo build`가 아닌 `cargo test`를 실행할 때만 테스트 코드를 컴파일하고 실행하라고 지시합니다. 이는 라이브러리만 빌드하고자 할 때 컴파일 시간을 절약하고, 컴파일된 결과물에 테스트가 포함되지 않아 공간 절약에도 기여합니다. 통합 테스트는 다른 디렉토리에 위치하기 때문에 `#[cfg(test)]` 어노테이션이 필요하지 않습니다. 하지만 단위 테스트는 코드와 동일한 파일에 위치하기 때문에, 결과물에 포함되지 않도록 `#[cfg(test)]`를 사용합니다.

이 장의 첫 섹션에서 `cargo new`가 자동으로 생성한 테스트 모듈과 함수 예제를 다시 살펴봅시다:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

이 코드는 자동으로 생성된 테스트 모듈입니다. `cfg` 속성은 *configuration* (구성)을 의미하며 Rust에게 특정 구성 옵션이 주어진 경우에만 해당 항목을 포함하도록 지시합니다. 여기서 구성 옵션은 `test`이며, Rust에서 테스트를 컴파일하고 실행할 때 제공됩니다. `cfg` 속성을 사용하면, Cargo는 `cargo test`를 사용해 테스트를 적극적으로 실행하는 경우에만 테스트 코드를 컴파일합니다. 이 모듈 내의 헬퍼 함수뿐만 아니라 `#[test]`로 주석 처리된 함수도 포함됩니다.

#### 비공개 함수 테스트하기

비공개 함수를 직접 테스트할지에 대해 테스트 커뮤니티 내에서 의견이 분분하며, 일부 언어는 비공개 함수 테스트를 어렵거나 불가능하게 만듭니다. 여러분이 어떤 테스트 방식을 선호하든, Rust의 접근성 규칙은 비공개 함수를 테스트할 수 있도록 허용합니다. 아래 비공개 함수 `internal_adder`를 포함한 코드를 살펴보세요.

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

##### 비공개 함수 테스트하기

`internal_adder` 함수는 `pub`로 표시되지 않았지만, 테스트는 일반 Rust 코드이고 `tests` 모듈도 또 다른 모듈에 불과하기 때문에 `internal_adder`를 테스트 스코프로 가져와 호출할 수 있습니다. 비공개 함수를 테스트하지 않아야 한다고 생각한다면, Rust는 이를 강제하지 않으므로 여러분의 선택에 달려 있습니다.